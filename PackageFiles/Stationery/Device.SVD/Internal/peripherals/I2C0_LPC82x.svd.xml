<!--
Devices using this peripheral: 
      LPC82x
-->
      <peripheral>
         <?sourceFile "I2C0_LPC82x" ?>
         <name>I2C0</name>
         <description>I2C0-bus interface</description>
         <groupName>I2C</groupName>
         <headerStructName>I2C0</headerStructName>
         <baseAddress>0x40050000</baseAddress>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xFFFFFFFF</resetMask>
         <addressBlock>
            <offset>0x0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0xC</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x10</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x20</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x40</offset>
            <size>0x1C</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x80</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CFG</name>
               <description>Configuration for shared functions</description>
               <addressOffset>0x0</addressOffset>
               <fields>
                  <field>
                     <name>MSTEN</name>
                     <description>Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. The I2C Master function is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. The I2C Master function is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVEN</name>
                     <description>Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. The I2C slave function is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. The I2C slave function is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONEN</name>
                     <description>Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. The I2C monitor function is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. The I2C monitor function is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TIMEOUTEN</name>
                     <description>I2C bus Time-out Enable. When disabled, the time-out function is internally reset</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Time-out function is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONCLKSTR</name>
                     <description>Monitor function Clock Stretching</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. The monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. The monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the monitor function</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>STAT</name>
               <description>Status register for Master, Slave, and Monitor functions</description>
               <addressOffset>0x4</addressOffset>
               <resetValue>0x801</resetValue>
               <fields>
                  <field>
                     <name>MSTPENDING</name>
                     <description>Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>IN_PROGRESS</name>
                           <description>In progress. Communication is in progress and the Master function is busy and cannot currently accept a command</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PENDING</name>
                           <description>Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSTATE</name>
                     <description>Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function.  All other values are reserved</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>IDLE</name>
                           <description>Idle. The Master function is available to be used for a new transaction</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RECEIVE_READY</name>
                           <description>Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TRANSMIT_READY</name>
                           <description>Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NACK_ADDRESS</name>
                           <description>NACK Address. Slave NACKed address</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NACK_DATA</name>
                           <description>NACK Data. Slave NACKed transmitted data</description>
                           <value>0x4</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTARBLOSS</name>
                     <description>Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_LOSS</name>
                           <description>No loss. No Arbitration Loss has occurred</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ARBITRATION_LOSS</name>
                           <description>Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSTSTPERR</name>
                     <description>Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_ERROR</name>
                           <description>No Start/Stop Error has occurred</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>STARTSTOP_ERROR</name>
                           <description>Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVPENDING</name>
                     <description>Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>IN_PROGRESS</name>
                           <description>In progress. The Slave function does not currently need service</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PENDING</name>
                           <description>Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVSTATE</name>
                     <description>Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SLAVE_ADDRESS</name>
                           <description>Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SLAVE_RECEIVE</name>
                           <description>Slave receive. Received data is available (Slave Receiver mode)</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SLAVE_TRANSMIT</name>
                           <description>Slave transmit. Data can be transmitted (Slave Transmitter mode)</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RESERVED</name>
                           <description>Reserved</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVNOTSTR</name>
                     <description>Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>STRETCHING</name>
                           <description>Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NOT_STRETCHING</name>
                           <description>Not stretching. The slave function is not currently stretching the I2C bus clock. Deep-sleep or Power-down mode could be entered at this time</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVIDX</name>
                     <description>Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SLAVE_ADDRESS_0_WAS</name>
                           <description>Slave address 0 was matched</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SLAVE_ADDRESS_1_WAS</name>
                           <description>Slave address 1 was matched</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SLAVE_ADDRESS_2_WAS</name>
                           <description>Slave address 2 was matched</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SLAVE_ADDRESS_3_WAS</name>
                           <description>Slave address 3 was matched</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVSEL</name>
                     <description>Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_SELECTED</name>
                           <description>Not selected. The Slave function is not currently selected</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SELECTED</name>
                           <description>Selected. The Slave function is currently selected</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVDESEL</name>
                     <description>Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_DESELECTED</name>
                           <description>Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DESELECTED</name>
                           <description>Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONRDY</name>
                     <description>Monitor Ready. This flag is cleared when the MONRXDAT register is read</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_DATA</name>
                           <description>No data. The Monitor function does not currently have data available</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DATA_WAITING</name>
                           <description>Data waiting. The Monitor function has data waiting to be read</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONOV</name>
                     <description>Monitor Overflow flag</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_OVERRUN</name>
                           <description>No overrun. Monitor data has not overrun</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>OVERRUN</name>
                           <description>Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONACTIVE</name>
                     <description>Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INACTIVE</name>
                           <description>Inactive. The Monitor function considers the I2C bus to be inactive</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE</name>
                           <description>Active. The Monitor function considers the I2C bus to be active</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONIDLE</name>
                     <description>Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_IDLE</name>
                           <description>Not idle. The I2C bus is not idle, or this flag has been cleared by software</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>IDLE</name>
                           <description>Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EVENTTIMEOUT</name>
                     <description>Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_TIME_OUT</name>
                           <description>No time-out. I2C bus events have not caused a time-out</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EVENT_TIME_OUT</name>
                           <description>Event time-out. The time between I2C bus events has been longer than the time specified by the I2C TIMEOUT register</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SCLTIMEOUT</name>
                     <description>SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_TIME_OUT</name>
                           <description>No time-out. SCL low time has not caused a time-out</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TIME_OUT</name>
                           <description>Time-out. SCL low time has caused a time-out</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTENSET</name>
               <description>Interrupt Enable Set and read register</description>
               <addressOffset>0x8</addressOffset>
               <fields>
                  <field>
                     <name>MSTPENDINGEN</name>
                     <description>Master Pending interrupt Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MSTPENDING_INTER</name>
                           <description>The MstPending interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MSTPENDING_INTER</name>
                           <description>The MstPending interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTARBLOSSEN</name>
                     <description>Master Arbitration Loss interrupt Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MSTARBLOSS_INTER</name>
                           <description>The MstArbLoss interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MSTARBLOSS_INTER</name>
                           <description>The MstArbLoss interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSTSTPERREN</name>
                     <description>Master Start/Stop Error interrupt Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MSTSTSTPERR_INTE</name>
                           <description>The MstStStpErr interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MSTSTSTPERR_INTE</name>
                           <description>The MstStStpErr interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVPENDINGEN</name>
                     <description>Slave Pending interrupt Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_SLVPENDING_INTER</name>
                           <description>The SlvPending interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_SLVPENDING_INTER</name>
                           <description>The SlvPending interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVNOTSTREN</name>
                     <description>Slave Not Stretching interrupt Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_SLVNOTSTR_INTERR</name>
                           <description>The SlvNotStr interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_SLVNOTSTR_INTERR</name>
                           <description>The SlvNotStr interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVDESELEN</name>
                     <description>Slave Deselect interrupt Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_SLVDESEL_INTERRU</name>
                           <description>The SlvDeSel interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_SLVDESEL_INTERRU</name>
                           <description>The SlvDeSel interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONRDYEN</name>
                     <description>Monitor data Ready interrupt Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MONRDY_INTERRUPT</name>
                           <description>The MonRdy interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MONRDY_INTERRUPT</name>
                           <description>The MonRdy interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONOVEN</name>
                     <description>Monitor Overrun interrupt Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MONOV_INTERRUPT</name>
                           <description>The MonOv interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MONOV_INTERRUPT</name>
                           <description>The MonOv interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONIDLEEN</name>
                     <description>Monitor Idle interrupt Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_MONIDLE_INTERRUP</name>
                           <description>The MonIdle interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_MONIDLE_INTERRUP</name>
                           <description>The MonIdle interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EVENTTIMEOUTEN</name>
                     <description>Event time-out interrupt Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_EVENT_TIME_OUT_I</name>
                           <description>The Event time-out interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_EVENT_TIME_OUT_I</name>
                           <description>The Event time-out interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SCLTIMEOUTEN</name>
                     <description>SCL time-out interrupt Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_SCL_TIME_OUT_INT</name>
                           <description>The SCL time-out interrupt is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_SCL_TIME_OUT_INT</name>
                           <description>The SCL time-out interrupt is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTENCLR</name>
               <description>Interrupt Enable Clear register</description>
               <addressOffset>0xC</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>MSTPENDINGCLR</name>
                     <description>Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTARBLOSSCLR</name>
                     <description>Master Arbitration Loss interrupt clear</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTSTSTPERRCLR</name>
                     <description>Master Start/Stop Error interrupt clear</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVPENDINGCLR</name>
                     <description>Slave Pending interrupt clear</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVNOTSTRCLR</name>
                     <description>Slave Not Stretching interrupt clear</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVDESELCLR</name>
                     <description>Slave Deselect interrupt clear</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONRDYCLR</name>
                     <description>Monitor data Ready interrupt clear</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONOVCLR</name>
                     <description>Monitor Overrun interrupt clear</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONIDLECLR</name>
                     <description>Monitor Idle interrupt clear</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EVENTTIMEOUTCLR</name>
                     <description>Event time-out interrupt clear</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCLTIMEOUTCLR</name>
                     <description>SCL time-out interrupt clear</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMEOUT</name>
               <description>Time-out value register</description>
               <addressOffset>0x10</addressOffset>
               <resetValue>0xFFFF</resetValue>
               <fields>
                  <field>
                     <name>TOMIN</name>
                     <description>Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TO</name>
                     <description>Time-out time value. Specifies the time-out interval value in increments of 16 I 2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A time-out will occur after 65,536 counts of the I2C function clock</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLKDIV</name>
               <description>Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME</description>
               <addressOffset>0x14</addressOffset>
               <fields>
                  <field>
                     <name>DIVVAL</name>
                     <description>This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTSTAT</name>
               <description>Interrupt Status register for Master, Slave, and Monitor functions</description>
               <addressOffset>0x18</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>MSTPENDING</name>
                     <description>Master Pending</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTARBLOSS</name>
                     <description>Master Arbitration Loss flag</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTSTSTPERR</name>
                     <description>Master Start/Stop Error flag</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVPENDING</name>
                     <description>Slave Pending</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVNOTSTR</name>
                     <description>Slave Not Stretching status</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLVDESEL</name>
                     <description>Slave Deselected flag</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONRDY</name>
                     <description>Monitor Ready</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONOV</name>
                     <description>Monitor Overflow flag</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONIDLE</name>
                     <description>Monitor Idle flag</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EVENTTIMEOUT</name>
                     <description>Event time-out Interrupt flag</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCLTIMEOUT</name>
                     <description>SCL time-out Interrupt flag</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTCTL</name>
               <description>Master control register</description>
               <addressOffset>0x20</addressOffset>
               <fields>
                  <field>
                     <name>MSTCONTINUE</name>
                     <description>Master Continue. This bit is write-only</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CONTINUE</name>
                           <description>Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSTART</name>
                     <description>Master Start control. This bit is write-only</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>START</name>
                           <description>Start. A Start will be generated on the I2C bus at the next allowed time</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSTOP</name>
                     <description>Master Stop control. This bit is write-only</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>STOP</name>
                           <description>Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTDMA</name>
                     <description>Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a  Start or Stop.This bit is read/write</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE</name>
                           <description>Disable. No DMA requests are generated for master operation</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE</name>
                           <description>Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTTIME</name>
               <description>Master timing configuration</description>
               <addressOffset>0x24</addressOffset>
               <resetValue>0x77</resetValue>
               <fields>
                  <field>
                     <name>MSTSCLLOW</name>
                     <description>Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter tLOW in the I2C bus specification. I2C bus specification parameters tBUF and t SU;STA have the same values and are also controlled by MSTSCLLOW</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>2_CLOCKS</name>
                           <description>2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>3_CLOCKS</name>
                           <description>3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_CLOCKS</name>
                           <description>4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>5_CLOCKS</name>
                           <description>5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>6_CLOCKS</name>
                           <description>6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>7_CLOCKS</name>
                           <description>7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>8_CLOCKS</name>
                           <description>8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>9_CLOCKS</name>
                           <description>9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider</description>
                           <value>0x7</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSTSCLHIGH</name>
                     <description>Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>2_CLOCKS</name>
                           <description>2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>3_CLOCKS</name>
                           <description>3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_CLOCKS</name>
                           <description>4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>5_CLOCKS</name>
                           <description>5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>6_CLOCKS</name>
                           <description>6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>7_CLOCKS</name>
                           <description>7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>8_CLOCKS</name>
                           <description>8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>9_CLOCKS</name>
                           <description>9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider</description>
                           <value>0x7</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTDAT</name>
               <description>Combined Master receiver and transmitter data register</description>
               <addressOffset>0x28</addressOffset>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>DATA</name>
                     <description>Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLVCTL</name>
               <description>Slave control register</description>
               <addressOffset>0x40</addressOffset>
               <fields>
                  <field>
                     <name>SLVCONTINUE</name>
                     <description>Slave Continue</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CONTINUE</name>
                           <description>Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVNACK</name>
                     <description>Slave NACK</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NACK</name>
                           <description>NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVDMA</name>
                     <description>Slave DMA enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. No DMA requests are issued for Slave mode operation</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. DMA requests are issued for I2C slave data transmission and reception</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLVDAT</name>
               <description>Combined Slave receiver and transmitter data register</description>
               <addressOffset>0x44</addressOffset>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>DATA</name>
                     <description>Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLVADR0</name>
               <description>Slave address 0</description>
               <addressOffset>0x48</addressOffset>
               <resetValue>0x1</resetValue>
               <fields>
                  <field>
                     <name>SADISABLE</name>
                     <description>Slave Address n Disable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>IGNORED_SLAVE_ADDRES</name>
                           <description>Ignored Slave Address n is ignored</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVADR</name>
                     <description>Seven bit slave address that is compared to received addresses if enabled</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>3</dim>
               <dimIncrement>4</dimIncrement>
               <dimIndex>1,2,3</dimIndex>
               <name>SLVADR%s</name>
               <description>Slave address 0</description>
               <addressOffset>0x4C</addressOffset>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>SADISABLE</name>
                     <description>Slave Address n Disable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>IGNORED_SLAVE_ADDRES</name>
                           <description>Ignored Slave Address n is ignored</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVADR</name>
                     <description>Seven bit slave address that is compared to received addresses if enabled</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLVQUAL0</name>
               <description>Slave Qualification for address 0</description>
               <addressOffset>0x58</addressOffset>
               <fields>
                  <field>
                     <name>QUALMODE0</name>
                     <description>Reserved. Read value is undefined, only zero should be written</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>MASK</name>
                           <description>The SLVQUAL0 field is used as a logical mask for matching address 0</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXTENDMASK</name>
                           <description>The SLVQUAL0 field is used to extend address 0 matching in a range of addresses</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLVQUAL0</name>
                     <description>Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] &lt;= received address &lt; = SLVQUAL0[7:1])</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MONRXDAT</name>
               <description>Monitor receiver data register</description>
               <addressOffset>0x80</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>MONRXDAT</name>
                     <description>Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins, and adds indication of Start, Repeated Start, and data NACK</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MONSTART</name>
                     <description>Monitor Received Start</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_DETECT</name>
                           <description>No detect. The monitor function has not detected a Start event on the I2C bus</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>START_DETECT</name>
                           <description>Start detect. The monitor function has detected a Start event on the I2C bus</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONRESTART</name>
                     <description>Monitor Received Repeated Start</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_START_DETECT</name>
                           <description>No start detect. The monitor function has not detected a Repeated Start event on the I2C bus</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>REPEATED_START_DETEC</name>
                           <description>Repeated start detect. The monitor function has detected a Repeated Start event on the I 2C bus</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MONNACK</name>
                     <description>Monitor Received NACK</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ACKNOWLEDGED</name>
                           <description>Acknowledged. The data currently being provided by the monitor function was acknowledged by at least one master or slave receiver</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NOT_ACKNOWLEDGED</name>
                           <description>Not acknowledged. The data currently being provided by the monitor function was not acknowledged by any receiver</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
