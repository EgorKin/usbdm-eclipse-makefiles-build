<!--
Devices using this peripheral: 
      LPC82x
-->
      <peripheral>
         <?sourceFile "DMA_LPC82x" ?>
         <name>DMA</name>
         <description>DMA controller</description>
         <groupName>DMA</groupName>
         <headerStructName>DMA</headerStructName>
         <baseAddress>0x50008000</baseAddress>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xFFFFFFFF</resetMask>
         <addressBlock>
            <offset>0x0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x20</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x28</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x30</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x38</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x40</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x48</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x50</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x58</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x60</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x68</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x70</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x78</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x400</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x410</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x420</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x430</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x440</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x450</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x460</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x470</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x480</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x490</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4A0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4B0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4C0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4D0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4E0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x4F0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x500</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x510</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CTRL</name>
               <description>DMA control</description>
               <addressOffset>0x0</addressOffset>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>DMA controller master enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. The DMA controller is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTSTAT</name>
               <description>Interrupt status</description>
               <addressOffset>0x4</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>ACTIVEINT</name>
                     <description>Summarizes whether any enabled interrupts are pending</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_PENDING</name>
                           <description>Not pending. No enabled interrupts are pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PENDING</name>
                           <description>Pending. At least one enabled interrupt is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ACTIVEERRINT</name>
                     <description>Summarizes whether any error interrupts are pending</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_PENDING</name>
                           <description>Not pending. No error interrupts are pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PENDING</name>
                           <description>Pending. At least one error interrupt is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SRAMBASE</name>
               <description>SRAM address of the channel configuration table</description>
               <addressOffset>0x8</addressOffset>
               <fields>
                  <field>
                     <name>OFFSET</name>
                     <description>Address bits 31:9 of the beginning of the DMA descriptor table. For 18 channels, the table must begin on a 512 byte boundary</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>23</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ENABLESET0</name>
               <description>Channel Enable read and Set for all DMA channels</description>
               <addressOffset>0x20</addressOffset>
               <fields>
                  <field>
                     <name>ENA</name>
                     <description>Enable for DMA channels 17:0. Bit n enables or disables DMA channel n.  0 = disabled. 1 = enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ENABLECLR0</name>
               <description>Channel Enable Clear for all DMA channels</description>
               <addressOffset>0x28</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>CLR</name>
                     <description>Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVE0</name>
               <description>Channel Active status for all DMA channels</description>
               <addressOffset>0x30</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>Active flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not active. 1 = active</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUSY0</name>
               <description>Channel Busy status for all DMA channels</description>
               <addressOffset>0x38</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>BSY</name>
                     <description>Busy flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = not busy. 1 = busy</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ERRINT0</name>
               <description>Error Interrupt status for all DMA channels</description>
               <addressOffset>0x40</addressOffset>
               <fields>
                  <field>
                     <name>ERR</name>
                     <description>Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. 0 = error interrupt is not active. 1 = error interrupt is active</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTENSET0</name>
               <description>Interrupt Enable read and Set for all DMA channels</description>
               <addressOffset>0x48</addressOffset>
               <fields>
                  <field>
                     <name>INTEN</name>
                     <description>Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTENCLR0</name>
               <description>Interrupt Enable Clear for all DMA channels</description>
               <addressOffset>0x50</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>CLR</name>
                     <description>Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTA0</name>
               <description>Interrupt A status for all DMA channels</description>
               <addressOffset>0x58</addressOffset>
               <fields>
                  <field>
                     <name>IA</name>
                     <description>Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTB0</name>
               <description>Interrupt B status for all DMA channels</description>
               <addressOffset>0x60</addressOffset>
               <fields>
                  <field>
                     <name>IB</name>
                     <description>Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SETVALID0</name>
               <description>Set ValidPending control bits for all DMA channels</description>
               <addressOffset>0x68</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>SV</name>
                     <description>SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the VALIDPENDING control bit for DMA channel n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SETTRIG0</name>
               <description>Set Trigger control bits for all DMA channels</description>
               <addressOffset>0x70</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>TRIG</name>
                     <description>Set Trigger control bit for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA channel n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ABORT0</name>
               <description>Channel Abort control for all DMA channels</description>
               <addressOffset>0x78</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>ABORTCTRL</name>
                     <description>Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = aborts DMA operations on channel n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>18</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFG0</name>
               <description>Configuration register for DMA channel 0</description>
               <addressOffset>0x400</addressOffset>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>PERIPHREQEN</name>
                     <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Peripheral DMA requests are disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Peripheral DMA requests are enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>HWTRIGEN</name>
                     <description>Hardware Triggering Enable for this channel</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Hardware triggering is not used</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Use hardware triggering</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TRIGPOL</name>
                     <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ACTIVE_LOW__FALLING</name>
                           <description>Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE_HIGH__RISING</name>
                           <description>Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TRIGTYPE</name>
                     <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>EDGE</name>
                           <description>Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LEVEL</name>
                           <description>Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted.  Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted.  However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TRIGBURST</name>
                     <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SINGLE_TRANSFER</name>
                           <description>Single transfer. Hardware trigger causes a single transfer</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BURST_TRANSFER</name>
                           <description>Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BURSTPOWER</name>
                     <description>Burst Power is used in two ways. It always selects the address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (20). 0001: Burst size = 2 (21). 0010: Burst size = 4 (22). ... 1010: Burst size = 1024 (210). This corresponds to the maximum supported transfer count. others: not supported. The total transfer length as defined in the XFERCOUNT bits in the XFERCFG register must be an even multiple of the burst size</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>SRCBURSTWRAP</name>
                     <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped, meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Source burst wrapping is not enabled for this DMA channel</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Source burst wrapping is enabled for this DMA channel</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DSTBURSTWRAP</name>
                     <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped, meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Destination burst wrapping is not enabled for this DMA channel</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Destination burst wrapping is enabled for this DMA channel</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CHPRIORITY</name>
                     <description>Priority of this channel when multiple DMA requests are pending.  Eight priority levels are supported.  0x0 = highest priority. 0x7 = lowest priority</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTLSTAT0</name>
               <description>Control and status register for DMA channel 0</description>
               <addressOffset>0x404</addressOffset>
               <access>read-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>VALIDPENDING</name>
                     <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT_ON_DMA_OPE</name>
                           <description>No effect on DMA operation</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALID_PENDING</name>
                           <description>Valid pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TRIG</name>
                     <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_TRIGGERED</name>
                           <description>Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TRIGGERED</name>
                           <description>Triggered. The trigger for this DMA channel is set. DMA operations will be carried out</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>XFERCFG0</name>
               <description>Transfer configuration register for DMA channel 0</description>
               <addressOffset>0x408</addressOffset>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>CFGVALID</name>
                     <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_VALID</name>
                           <description>Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALID</name>
                           <description>Valid. The current channel descriptor is considered valid</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RELOAD</name>
                     <description>Indicates whether the channel&apos;s control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled. Do not reload the channels&apos; control structure when the current descriptor is exhausted</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled. Reload the channels&apos; control structure when the current descriptor is exhausted</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SWTRIG</name>
                     <description>Software Trigger</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOTSET</name>
                           <description>When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SET</name>
                           <description>When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CLRTRIG</name>
                     <description>Clear Trigger</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NOT_CLEARED</name>
                           <description>Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CLEARED</name>
                           <description>Cleared. The trigger is cleared when this descriptor is exhausted</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SETINTA</name>
                     <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SET</name>
                           <description>Set. The INTA flag for this channel will be set when the current descriptor is exhausted</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SETINTB</name>
                     <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_EFFECT</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SET</name>
                           <description>Set. The INTB flag for this channel will be set when the current descriptor is exhausted</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>WIDTH</name>
                     <description>Transfer width used for this DMA channel</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>8_BIT_TRANSFERS_ARE</name>
                           <description>8-bit transfers are performed (8-bit source reads and destination writes)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>16_BIT_TRANSFERS_ARE</name>
                           <description>16-bit transfers are performed (16-bit source reads and destination writes)</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>32_BIT_TRANSFERS_ARE</name>
                           <description>32-bit transfers are performed (32-bit source reads and destination writes)</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RESERVED_SETTING</name>
                           <description>Reserved setting, do not use</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SRCINC</name>
                     <description>Determines whether the source address is incremented for each DMA transfer</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_INCREMENT</name>
                           <description>No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>1_X_WIDTH</name>
                           <description>1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2_X_WIDTH</name>
                           <description>2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_X_WIDTH</name>
                           <description>4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DSTINC</name>
                     <description>Determines whether the destination address is incremented for each DMA transfer</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_INCREMENT</name>
                           <description>No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>1_X_WIDTH</name>
                           <description>1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2_X_WIDTH</name>
                           <description>2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_X_WIDTH</name>
                           <description>4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>XFERCOUNT</name>
                     <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register derivedFrom="CFG0"> <name>CFG1</name> <addressOffset>0x410</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT1</name> <addressOffset>0x414</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG1</name> <addressOffset>0x418</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG2</name> <addressOffset>0x420</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT2</name> <addressOffset>0x424</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG2</name> <addressOffset>0x428</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG3</name> <addressOffset>0x430</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT3</name> <addressOffset>0x434</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG3</name> <addressOffset>0x438</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG4</name> <addressOffset>0x440</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT4</name> <addressOffset>0x444</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG4</name> <addressOffset>0x448</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG5</name> <addressOffset>0x450</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT5</name> <addressOffset>0x454</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG5</name> <addressOffset>0x458</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG6</name> <addressOffset>0x460</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT6</name> <addressOffset>0x464</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG6</name> <addressOffset>0x468</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG7</name> <addressOffset>0x470</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT7</name> <addressOffset>0x474</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG7</name> <addressOffset>0x478</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG8</name> <addressOffset>0x480</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT8</name> <addressOffset>0x484</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG8</name> <addressOffset>0x488</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG9</name> <addressOffset>0x490</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT9</name> <addressOffset>0x494</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG9</name> <addressOffset>0x498</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG10</name> <addressOffset>0x4A0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT10</name> <addressOffset>0x4A4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG10</name> <addressOffset>0x4A8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG11</name> <addressOffset>0x4B0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT11</name> <addressOffset>0x4B4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG11</name> <addressOffset>0x4B8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG12</name> <addressOffset>0x4C0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT12</name> <addressOffset>0x4C4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG12</name> <addressOffset>0x4C8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG13</name> <addressOffset>0x4D0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT13</name> <addressOffset>0x4D4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG13</name> <addressOffset>0x4D8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG14</name> <addressOffset>0x4E0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT14</name> <addressOffset>0x4E4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG14</name> <addressOffset>0x4E8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG15</name> <addressOffset>0x4F0</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT15</name> <addressOffset>0x4F4</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG15</name> <addressOffset>0x4F8</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG16</name> <addressOffset>0x500</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT16</name> <addressOffset>0x504</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG16</name> <addressOffset>0x508</addressOffset> </register>
            <register derivedFrom="CFG0"> <name>CFG17</name> <addressOffset>0x510</addressOffset> </register>
            <register derivedFrom="CTLSTAT0"> <name>CTLSTAT17</name> <addressOffset>0x514</addressOffset> </register>
            <register derivedFrom="XFERCFG0"> <name>XFERCFG17</name> <addressOffset>0x518</addressOffset> </register>
         </registers>
      </peripheral>
