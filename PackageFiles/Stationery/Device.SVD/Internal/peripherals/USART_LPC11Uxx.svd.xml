<!--
Devices using this peripheral: 
      LPC11Uxx
      LPC13Uxx
-->
      <peripheral>
         <?sourceFile "USART_LPC11Uxx" ?>
         <name>USART</name>
         <description>USART</description>
         <groupName>USART</groupName>
         <headerStructName>USART</headerStructName>
         <baseAddress>0x40008000</baseAddress>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xFFFFFFFF</resetMask>
         <addressBlock>
            <offset>0x0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x8</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0xC</offset>
            <size>0x28</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x40</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <offset>0x48</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>DLL</name>
               <description>Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)</description>
               <addressOffset>0x0</addressOffset>
               <resetValue>0x1</resetValue>
               <fields>
                  <field>
                     <name>DLLSB</name>
                     <description>The USART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the USART</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RBR</name>
               <description>Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)</description>
               <addressOffset>0x0</addressOffset>
               <access>read-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>RBR</name>
                     <description>The USART Receiver Buffer Register contains the oldest received byte in the USART RX FIFO</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>THR</name>
               <description>Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)</description>
               <addressOffset>0x0</addressOffset>
               <access>write-only</access>
               <resetMask>0x0</resetMask>
               <fields>
                  <field>
                     <name>THR</name>
                     <description>Writing to the USART Transmit Holding Register causes the data to be stored in the USART transmit FIFO. The byte will be sent when it is the oldest byte in the FIFO and the transmitter is available</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DLM</name>
               <description>Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)</description>
               <addressOffset>0x4</addressOffset>
               <fields>
                  <field>
                     <name>DLMSB</name>
                     <description>The USART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the USART</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IER</name>
               <description>Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0)</description>
               <addressOffset>0x4</addressOffset>
               <fields>
                  <field>
                     <name>RBRINTEN</name>
                     <description>RBR Interrupt Enable. Enables the Receive Data Available interrupt. It also controls the Character Receive Time-out interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_THE_RDA_INTE</name>
                           <description>Disable the RDA interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_THE_RDA_INTER</name>
                           <description>Enable the RDA interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>THREINTEN</name>
                     <description>THRE Interrupt Enable. Enables the THRE interrupt. The status of this interrupt can be read from LSR[5]</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_THE_THRE_INT</name>
                           <description>Disable the THRE interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_THE_THRE_INTE</name>
                           <description>Enable the THRE interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RLSINTEN</name>
                     <description>Enables the Receive Line Status interrupt. The status of this interrupt can be read from LSR[4:1]</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_THE_RLS_INTE</name>
                           <description>Disable the RLS interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_THE_RLS_INTER</name>
                           <description>Enable the RLS interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MSINTEN</name>
                     <description>Enables the Modem Status interrupt. The components of this interrupt can be read from the MSR</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_THE_MS_INTER</name>
                           <description>Disable the MS interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_THE_MS_INTERR</name>
                           <description>Enable the MS interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ABEOINTEN</name>
                     <description>Enables the end of auto-baud interrupt</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_END_OF_AUTO_</name>
                           <description>Disable end of auto-baud Interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_END_OF_AUTO_B</name>
                           <description>Enable end of auto-baud Interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ABTOINTEN</name>
                     <description>Enables the auto-baud time-out interrupt</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_AUTO_BAUD_TI</name>
                           <description>Disable auto-baud time-out Interrupt</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_AUTO_BAUD_TIM</name>
                           <description>Enable auto-baud time-out Interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>FCR</name>
               <description>FIFO Control Register. Controls USART FIFO usage and modes</description>
               <addressOffset>0x8</addressOffset>
               <access>write-only</access>
               <fields>
                  <field>
                     <name>FIFOEN</name>
                     <description>FIFO enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>USART FIFOs are disabled. Must not be used in the application</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Active high enable for both USART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper USART operation. Any transition on this bit will automatically clear the USART FIFOs</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RXFIFORES</name>
                     <description>RX FIFO Reset</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_IMPACT</name>
                           <description>No impact on either of USART FIFOs</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CLEAR</name>
                           <description>Writing a logic 1 to FCR[1] will clear all bytes in USART Rx FIFO, reset the pointer logic. This bit is self-clearing</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TXFIFORES</name>
                     <description>TX FIFO Reset</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_IMPACT</name>
                           <description>No impact on either of USART FIFOs</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CLEAR</name>
                           <description>Writing a logic 1 to FCR[2] will clear all bytes in USART TX FIFO, reset the pointer logic. This bit is self-clearing</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RXTL</name>
                     <description>RX Trigger Level. These two bits determine how many receiver USART FIFO characters must be written before an interrupt is activated</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>TRIGGER_LEVEL_0_1_C</name>
                           <description>Trigger level 0 (1 character or 0x01)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TRIGGER_LEVEL_1_4_C</name>
                           <description>Trigger level 1 (4 characters or 0x04)</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TRIGGER_LEVEL_2_8_C</name>
                           <description>Trigger level 2 (8 characters or 0x08)</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TRIGGER_LEVEL_3_14_</name>
                           <description>Trigger level 3 (14 characters or 0x0E)</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>IIR</name>
               <description>Interrupt ID Register. Identifies which interrupt(s) are pending</description>
               <addressOffset>0x8</addressOffset>
               <access>read-only</access>
               <resetValue>0x1</resetValue>
               <fields>
                  <field>
                     <name>INTSTATUS</name>
                     <description>Interrupt status. Note that IIR[0] is active low. The pending interrupt can be determined by evaluating IIR[3:1]</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>AT_LEAST_ONE_INTERRU</name>
                           <description>At least one interrupt is pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NO_INTERRUPT_IS_PEND</name>
                           <description>No interrupt is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>INTID</name>
                     <description>Interrupt identification. IER[3:1] identifies an interrupt corresponding to the USART Rx FIFO. All other values of IER[3:1] not listed below are reserved</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>1_RECEIVE_LINE_S</name>
                           <description>1   - Receive Line Status (RLS)</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2A__RECEIVE_DATA_AV</name>
                           <description>2a - Receive Data Available (RDA)</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2B__CHARACTER_TIME_</name>
                           <description>2b - Character Time-out Indicator (CTI)</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>3_THRE_INTERRUPT</name>
                           <description>3   - THRE Interrupt</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_MODEM_STATUS</name>
                           <description>4   - Modem status</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>FIFOEN</name>
                     <description>These bits are equivalent to FCR[0]</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ABEOINT</name>
                     <description>End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ABTOINT</name>
                     <description>Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LCR</name>
               <description>Line Control Register. Contains controls for frame formatting and break generation</description>
               <addressOffset>0xC</addressOffset>
               <fields>
                  <field>
                     <name>WLS</name>
                     <description>Word Length Select</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>5_BIT_CHARACTER_LENG</name>
                           <description>5-bit character length</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>6_BIT_CHARACTER_LENG</name>
                           <description>6-bit character length</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>7_BIT_CHARACTER_LENG</name>
                           <description>7-bit character length</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>8_BIT_CHARACTER_LENG</name>
                           <description>8-bit character length</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SBS</name>
                     <description>Stop Bit Select</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>1_STOP_BIT_</name>
                           <description>1 stop bit</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2_STOP_BITS_1_5_IF_</name>
                           <description>2 stop bits (1.5 if LCR[1:0]=00)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PE</name>
                     <description>Parity Enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_PARITY_GENER</name>
                           <description>Disable parity generation and checking</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_PARITY_GENERA</name>
                           <description>Enable parity generation and checking</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PS</name>
                     <description>Parity Select</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ODD_PARITY_NUMBER_O</name>
                           <description>Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EVEN_PARITY_NUMBER_</name>
                           <description>Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FORCED_1_STICK_PARIT</name>
                           <description>Forced 1 stick parity</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FORCED_0_STICK_PARIT</name>
                           <description>Forced 0 stick parity</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BC</name>
                     <description>Break Control</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_BREAK_TRANSM</name>
                           <description>Disable break transmission</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_BREAK_TRANSMI</name>
                           <description>Enable break transmission. Output pin USART TXD is forced to logic 0 when LCR[6] is active high</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DLAB</name>
                     <description>Divisor Latch Access Bit</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_ACCESS_TO_DI</name>
                           <description>Disable access to Divisor Latches</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_ACCESS_TO_DIV</name>
                           <description>Enable access to Divisor Latches</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>MCR</name>
               <description>Modem Control Register</description>
               <addressOffset>0x10</addressOffset>
               <fields>
                  <field>
                     <name>DTRCTRL</name>
                     <description>Source for modem output pin DTR. This bit reads as 0 when modem loopback mode is active</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTSCTRL</name>
                     <description>Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LMS</name>
                     <description>Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The DSR, CTS, DCD, and RI pins are ignored. Externally, DTR and  RTS are set inactive. Internally, the upper four bits of the MSR are driven by the lower four bits of the MCR. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_MODEM_LOOPBA</name>
                           <description>Disable modem loopback mode</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_MODEM_LOOPBAC</name>
                           <description>Enable modem loopback mode</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RTSEN</name>
                     <description>RTS enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_AUTO_RTS_FLO</name>
                           <description>Disable auto-rts flow control</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_AUTO_RTS_FLOW</name>
                           <description>Enable auto-rts flow control</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CTSEN</name>
                     <description>CTS enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_AUTO_CTS_FLO</name>
                           <description>Disable auto-cts flow control</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_AUTO_CTS_FLOW</name>
                           <description>Enable auto-cts flow control</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>LSR</name>
               <description>Line Status Register. Contains flags for transmit and receive status, including line errors</description>
               <addressOffset>0x14</addressOffset>
               <access>read-only</access>
               <resetValue>0x60</resetValue>
               <fields>
                  <field>
                     <name>RDR</name>
                     <description>Receiver Data Ready:LSR[0] is set when the RBR holds an unread character and is cleared when the USART RBR FIFO is empty</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>RBR_IS_EMPTY_</name>
                           <description>RBR is empty</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RBR_CONTAINS_VALID_D</name>
                           <description>RBR contains valid data</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>OE</name>
                     <description>Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when USART RSR has a new character assembled and the USART RBR FIFO is full. In this case, the USART RBR FIFO will not be overwritten and the character in the USART RSR will be lost</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INACTIVE</name>
                           <description>Overrun error status is inactive</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE</name>
                           <description>Overrun error status is active</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PE</name>
                     <description>Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the USART RBR FIFO</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INACTIVE</name>
                           <description>Parity error status is inactive</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE</name>
                           <description>Parity error status is active</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>FE</name>
                     <description>Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the USART RBR FIFO</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INACTIVE</name>
                           <description>Framing error status is inactive</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE</name>
                           <description>Framing error status is active</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BI</name>
                     <description>Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the USART RBR FIFO</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INACTIVE</name>
                           <description>Break interrupt status is inactive</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ACTIVE</name>
                           <description>Break interrupt status is active</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>THRE</name>
                     <description>Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty USART THR and is cleared on a THR write</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THR_CONTAINS_VALID_D</name>
                           <description>THR contains valid data</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THR_IS_EMPTY_</name>
                           <description>THR is empty</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TEMT</name>
                     <description>Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>VALID_D</name>
                           <description>THR and/or the TSR contains valid data</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EMPTY</name>
                           <description>THR and the TSR are empty</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RXFE</name>
                     <description>Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the USART FIFO</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_ERROR</name>
                           <description>RBR contains no USART RX errors or FCR[0]=0</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ERRO</name>
                           <description>USART RBR contains at least one USART RX error</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TXERR</name>
                     <description>Tx Error. In smart card T=0 operation, this bit is set when the smart card has NACKed a transmitted character, one more than the number of times indicated by the TXRETRY field</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSR</name>
               <description>Modem Status Register</description>
               <addressOffset>0x18</addressOffset>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>DCTS</name>
                     <description>Delta CTS. Set upon state change of input CTS. Cleared on an MSR read</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_CHANGE_DETECTED_O</name>
                           <description>No change detected on modem input, CTS</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>STATE_CHANGE_DETECTE</name>
                           <description>State change detected on modem input, CTS</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DDSR</name>
                     <description>Delta DSR. Set upon state change of input DSR. Cleared on an MSR read</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_CHANGE_DETECTED_O</name>
                           <description>No change detected on modem input, DSR</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>STATE_CHANGE_DETECTE</name>
                           <description>State change detected on modem input, DSR</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TERI</name>
                     <description>Trailing Edge RI. Set upon low to high transition of input RI. Cleared on an MSR read</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_CHANGE_DETECTED_O</name>
                           <description>No change detected on modem input, RI</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOW_TO_HIGH_TRANSITI</name>
                           <description>Low-to-high transition detected on RI</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DDCD</name>
                     <description>Delta DCD. Set upon state change of input DCD. Cleared on an MSR read</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_CHANGE_DETECTED_O</name>
                           <description>No change detected on modem input, DCD</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>STATE_CHANGE_DETECTE</name>
                           <description>State change detected on modem input, DCD</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CTS</name>
                     <description>Clear To Send State. Complement of input signal CTS. This bit is connected to MCR[1] in modem loopback mode</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DSR</name>
                     <description>Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR[0] in modem loopback mode</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RI</name>
                     <description>Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in modem loopback mode</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DCD</name>
                     <description>Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR[3] in modem loopback mode</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCR</name>
               <description>Scratch Pad Register. Eight-bit temporary storage for software</description>
               <addressOffset>0x1C</addressOffset>
               <fields>
                  <field>
                     <name>PAD</name>
                     <description>A readable, writable byte</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACR</name>
               <description>Auto-baud Control Register. Contains controls for the auto-baud feature</description>
               <addressOffset>0x20</addressOffset>
               <fields>
                  <field>
                     <name>START</name>
                     <description>This bit is automatically cleared after auto-baud completion</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>AUTO_BAUD_STOP_AUTO</name>
                           <description>Auto-baud stop (auto-baud is not running)</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>AUTO_BAUD_START_AUT</name>
                           <description>Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MODE</name>
                     <description>Auto-baud mode select bit</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>MODE_0_</name>
                           <description>Mode 0</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>MODE_1_</name>
                           <description>Mode 1</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>AUTORESTART</name>
                     <description>Start mode</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_RESTART</name>
                           <description>No restart</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RESTART_IN_CASE_OF_T</name>
                           <description>Restart in case of time-out (counter restarts at next USART Rx falling edge)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ABEOINTCLR</name>
                     <description>End of auto-baud interrupt clear bit (write only accessible)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>NO_IMPACT</name>
                           <description>Writing a 0 has no impact</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>CLEAR</name>
                           <description>Writing a 1 will clear the corresponding interrupt in the IIR</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="ABEOINTCLR" > <name>ABTOINTCLR</name> <description>Auto-baud time-out interrupt clear bit (write only accessible)</description> <bitOffset>9</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ICR</name>
               <description>IrDA Control Register. Enables and configures the IrDA (remote control) mode</description>
               <addressOffset>0x24</addressOffset>
               <fields>
                  <field>
                     <name>IRDAEN</name>
                     <description>IrDA mode enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>IRDA_MODE_IS_DISABLE</name>
                           <description>IrDA mode is disabled, USARTn acts as a standard USART</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>IRDA_MODE_IS_ENABLED</name>
                           <description>IrDA mode is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>IRDAINV</name>
                     <description>Serial input inverter</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>INVERTED</name>
                           <description>The serial input is not inverted</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NOT_INVERTED</name>
                           <description>The serial input is inverted. This has no effect on the serial output</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>FIXPULSEEN</name>
                     <description>IrDA fixed pulse width mode</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>IrDA fixed pulse width mode disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>IrDA fixed pulse width mode enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PULSEDIV</name>
                     <description>Configures the pulse width when FixPulseEn = 1</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>3_DIV_16_X_BAUD_RATE</name>
                           <description>3 / (16 x baud rate)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>2_X_TPCLK</name>
                           <description>2 x TPCLK</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>4_X_TPCLK</name>
                           <description>4 x TPCLK</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>8_X_TPCLK</name>
                           <description>8 x TPCLK</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>16_X_TPCLK</name>
                           <description>16 x TPCLK</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>32_X_TPCLK</name>
                           <description>32 x TPCLK</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>64_X_TPCLK</name>
                           <description>64 x TPCLK</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>128_X_TPCLK</name>
                           <description>128 x TPCLK</description>
                           <value>0x7</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>FDR</name>
               <description>Fractional Divider Register. Generates a clock input for the baud rate divider</description>
               <addressOffset>0x28</addressOffset>
               <resetValue>0x10</resetValue>
               <fields>
                  <field>
                     <name>DIVADDVAL</name>
                     <description>Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the USART baud rate</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>MULVAL</name>
                     <description>Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for USART to operate properly, regardless of whether the fractional baud rate generator is used or not</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OSR</name>
               <description>Oversampling Register. Controls the degree of oversampling during each bit time</description>
               <addressOffset>0x2C</addressOffset>
               <resetValue>0xF0</resetValue>
               <fields>
                  <field>
                     <name>OSFRAC</name>
                     <description>Fractional part of the oversampling ratio, in units of 1/8th of an input clock period. (001 = 0.125, ..., 111 = 0.875)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>OSINT</name>
                     <description>Integer part of the oversampling ratio, minus 1. The reset values equate to the normal operating mode of 16 input clocks per bit time</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>FDINT</name>
                     <description>In Smart Card mode, these bits act as a more-significant extension of the OSint field, allowing an oversampling ratio up to 2048 as required by ISO7816-3. In Smart Card mode, bits 14:4 should initially be set to 371, yielding an oversampling ratio of 372</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TER</name>
               <description>Transmit Enable Register. Turns off USART transmitter for use with software flow control</description>
               <addressOffset>0x30</addressOffset>
               <resetValue>0x80</resetValue>
               <fields>
                  <field>
                     <name>TXEN</name>
                     <description>When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HDEN</name>
               <description>Half duplex enable register</description>
               <addressOffset>0x40</addressOffset>
               <fields>
                  <field>
                     <name>HDEN</name>
                     <description>Half-duplex mode enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_HALF_DUPLEX_</name>
                           <description>Disable half-duplex mode</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_HALF_DUPLEX_M</name>
                           <description>Enable half-duplex mode</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCICTRL</name>
               <description>Smart Card Interface Control register. Enables and configures the Smart Card Interface feature</description>
               <addressOffset>0x48</addressOffset>
               <fields>
                  <field>
                     <name>SCIEN</name>
                     <description>Smart Card Interface Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SMART_CARD_INTERFACE</name>
                           <description>Smart card interface disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ASYNCHRONOUS_HALF_DU</name>
                           <description>Asynchronous half duplex smart card interface is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NACKDIS</name>
                     <description>NACK response disable. Only applicable in T=0</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>A NACK response is enabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>A NACK response is inhibited</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PROTSEL</name>
                     <description>Protocol selection as defined in the ISO7816-3 standard</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>T_EQ_0</name>
                           <description>T = 0</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>T_EQ_1</name>
                           <description>T = 1</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TXRETRY</name>
                     <description>When the protocol selection T bit (above) is 0, the field controls the maximum number of retransmissions that the USART will attempt if the remote device signals NACK. When NACK has occurred this number of times plus one, the Tx Error bit in the LSR is set, an interrupt is requested if enabled, and the USART is locked until the FIFO is cleared</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>XTRAGUARD</name>
                     <description>When the protocol selection T bit (above) is 0, this field indicates the number of bit times (ETUs) by which the guard time after a character transmitted by the USART should exceed the nominal 2 bit times. 0xFF in this field may indicate that there is just a single bit after a character and 11 bit times/character</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RS485CTRL</name>
               <description>RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes</description>
               <addressOffset>0x4C</addressOffset>
               <fields>
                  <field>
                     <name>NMMEN</name>
                     <description>NMM enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RXDIS</name>
                     <description>Receiver enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>THE_RECEIVER_IS_ENAB</name>
                           <description>The receiver is enabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>THE_RECEIVER_IS_DISA</name>
                           <description>The receiver is disabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>AADEN</name>
                     <description>AAD enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>AUTO_ADDRESS_DETECT_</name>
                           <description>Auto Address Detect (AAD) is disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>AUTO_ADDRESS_DETECT_</name>
                           <description>Auto Address Detect (AAD) is enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SEL</name>
                     <description>Select direction control pin</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>RTS</name>
                           <description>If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DTR</name>
                           <description>If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DCTRL</name>
                     <description>Auto direction control enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLE_AUTO_DIRECTI</name>
                           <description>Disable Auto Direction Control</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLE_AUTO_DIRECTIO</name>
                           <description>Enable Auto Direction Control</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>OINV</name>
                     <description>Polarity control. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>LOW</name>
                           <description>The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>HIGH</name>
                           <description>The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>RS485ADRMATCH</name>
               <description>RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode</description>
               <addressOffset>0x50</addressOffset>
               <fields>
                  <field>
                     <name>ADRMATCH</name>
                     <description>Contains the address match value</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RS485DLY</name>
               <description>RS-485/EIA-485 direction control delay</description>
               <addressOffset>0x54</addressOffset>
               <fields>
                  <field>
                     <name>DLY</name>
                     <description>Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SYNCCTRL</name>
               <description>Synchronous mode control register</description>
               <addressOffset>0x58</addressOffset>
               <fields>
                  <field>
                     <name>SYNC</name>
                     <description>Enables synchronous mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>DISABLED</name>
                           <description>Disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ENABLED</name>
                           <description>Enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CSRC</name>
                     <description>Clock source select</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SYNCHRONOUS_SLAVE_MO</name>
                           <description>Synchronous slave mode (SCLK in)</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SYNCHRONOUS_MASTER_M</name>
                           <description>Synchronous master mode (SCLK out)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>FES</name>
                     <description>Falling edge sampling</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>RISING</name>
                           <description>RxD is sampled on the rising edge of SCLK</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FALLING</name>
                           <description>RxD is sampled on the falling edge of SCLK</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TSBYPASS</name>
                     <description>Transmit synchronization bypass in synchronous slave mode</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SYNC</name>
                           <description>The input clock is synchronized prior to being used in clock edge detection logic</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>NOSYNC</name>
                           <description>The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CSCEN</name>
                     <description>Continuous master clock enable (used only when CSRC is 1)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SCLK_CYCLES_ONLY_WHE</name>
                           <description>SCLK cycles only when characters are being sent on TxD</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SCLK_RUNS_CONTINUOUS</name>
                           <description>SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SSDIS</name>
                     <description>Start/stop bits</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>SEND_START_AND_STOP_</name>
                           <description>Send start and stop bits as in other modes</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DO_NOT_SEND_STARTSTOP</name>
                           <description>Do not send start/stop bits</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CCCLR</name>
                     <description>Continuous clock clear</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>CSCEN_IS_UNDER_SOFTW</name>
                           <description>CSCEN is under software control</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>HARDWARE_CLEARS_CSCE</name>
                           <description>Hardware clears CSCEN after each character is received</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
