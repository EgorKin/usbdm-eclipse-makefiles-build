<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- can0_1mask.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="FlexCAN">

   <template><![CDATA[
      \t//! Base value for PCR (excluding MUX value)
      \tstatic constexpr uint32_t defaultPcrValue  = 0;\n\n
   ]]></template>
   
   <xi:include href="_mapPinsOption.xml"/>
   
   <!-- Note: second entry gets the tick irrespective of true/false value -->
   <binaryOption name="EnableFifo" 
      description="Enable Receive FIFO"
      toolTip="This option enables use of the receive FIFO in addition to the individual mailboxes.
               The number of individual mailboxes is reduced.">
      <choice value="0" name="Disabled" />
      <choice value="1" name="Enabled" isdefault />
   </binaryOption>

   <intOption name="NumberOfMessageBuffers" 
      description="Number of message buffers available"
      toolTip="This value is determined by the hardware"
      constant="true" 
      value="16" />

   <intOption name="NumberOfMessageFilters" 
      description="Number of message buffers available"
      toolTip="This value is determined by the hardware"
      constant="true" 
      value="40" />

   <template><![CDATA[
       \t//! Number of Message Buffers\n
       \tstatic constexpr unsigned NumberOfMessageBuffers =  $(NumberOfMessageBuffers);\n\n
       \t//! Number of Message Filters\n
       \tstatic constexpr unsigned NumberOfMessageFilters =  $(NumberOfMessageFilters);\n\n
   ]]></template>

   <!--
   Patterns for pattern and classHandler 
     -  %i replaced with peripheral instance e.g. FTM1 => 1, PTA => A
     -  %b replaced with peripheral base name e.g. FTM1 => = FTM
     -  %c replaced with peripheral C++ base class name e.g. FTM1 => = Ftm
     -  _IRQHandler is appended to the pattern (only)
   -->
   <irqOption name="oredIrqHandlingMethod"  
      description="ORed Interrupt handlers"
      toolTip="This selection allow the interrupt handler for this peripheral to be installed using several different methods"
      pattern="^%b%i_ORed$" 
      classHandler="%c%i::irqHandler" />

   <irqOption name="errorIrqHandlingMethod"  
      description="Error Interrupt handlers"
      toolTip="This selection allow the interrupt handler for this peripheral to be installed using several different methods"
      pattern="^%b%i_Error$" 
      classHandler="%c%i::errorIrqHandler" />

   <irqOption name="wakeupIrqHandlingMethod"  
      description="Wakeup Interrupt handlers"
      toolTip="This selection allow the interrupt handler for this peripheral to be installed using several different methods"
      pattern="^%b%i_WakeUp$" 
      classHandler="%c%i::wakeupIrqHandler" />

   <irqOption name="messagebufferIrqHandlingMethod"  
      description="Message Buffer Interrupt handlers"
      toolTip="This selection allow the interrupt handler for this peripheral to be installed using several different methods"
      pattern="^%b%i_MessageBuffer.*$" 
      classHandler="%c%i::messageBufferIrqHandler" />

   <signals/>
   
   
   <!-- Template is added to class within pin_mapping.h -->
   <template><![CDATA[
       \t//! Class based callback handler has been installed in vector table\n
       \tstatic constexpr bool irqHandlerInstalled = $(messagebufferIrqHandlingMethod);\n\n
       
       \tstatic constexpr unsigned OredIrqNumIndex                 = 0;
       \tstatic constexpr unsigned ErrorIrqNumIndex                = 1;
       \tstatic constexpr unsigned WakeupIrqNumIndex               = 2;
       \tstatic constexpr unsigned MessageBuffer_0_15_IrqNumIndex  = 3;
       \tstatic constexpr unsigned MessageBuffer_16_32_IrqNumIndex = 4;\n\n
   ]]></template>
       
   <intOption name="irqLevel" 
      description="IRQ Level in NVIC [0-15]"
      toolTip="Sets the priority level used to configure the NVIC\n
               Lower numbers represent higher priorities"
      value="8" min="0" max="15" 
   />
   
   <template><![CDATA[
      \t/**
      \t * Get Controller Host Interface input clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getChiClockFrequency() {
      \t   return SystemCoreClock;
      \t}\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t * Get Protocol Engine input clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getPeClockFrequency() {
      \t   if (can().CTRL1 & CAN_CTRL1_CLKSRC_MASK) {
      \t      return Osc0Info::getOscerClock();
      \t   }
      \t   else {
      \t      return SystemCoreClock;
      \t   }
      \t}\n\n
   ]]></template>

   <template><![CDATA[
       \t//! Default IRQ level\n
       \tstatic constexpr uint32_t irqLevel =  $(irqLevel);\n\n
   ]]></template>

   <template name="/CAN/NvicControl" namespace="all" ><![CDATA[
      \t/**
      \t * Enable Ored interrupts in NVIC
      \t */
      \tstatic void enableOredNvicInterrupts() {
      \t   NVIC_EnableIRQ(Info::irqNums[Info::OredIrqNumIndex]);
      \t}
      \t
      \t/**
      \t * Enable and set priority of Ored interrupts in NVIC
      \t * Any pending NVIC interrupts are first cleared.
      \t *
      \t * @param[in]  nvicPriority  Interrupt priority
      \t */
      \tstatic void enableOredNvicInterrupts(uint32_t nvicPriority) {
      \t   enableNvicInterrupt(Info::irqNums[Info::OredIrqNumIndex], nvicPriority);
      \t}
      \t
      \t/**
      \t * Disable Ored interrupts in NVIC
      \t */
      \tstatic void disableOredNvicInterrupts() {
      \t   NVIC_DisableIRQ(Info::irqNums[Info::OredIrqNumIndex]);
      \t}
      \t
      \t/**
      \t * Enable Message Buffer interrupts in NVIC
      \t */
      \tstatic void enableMessageBufferNvicInterrupts() {
      \t   NVIC_EnableIRQ(Info::irqNums[Info::MessageBuffer_0_15_IrqNumIndex]);
      \t   NVIC_EnableIRQ(Info::irqNums[Info::MessageBuffer_0_15_IrqNumIndex]);
      \t}
      \t
      \t/**
      \t * Enable and set priority of Message Buffer interrupts in NVIC
      \t * Any pending NVIC interrupts are first cleared.
      \t *
      \t * @param[in]  nvicPriority  Interrupt priority
      \t */
      \tstatic void enableMessageBufferNvicInterrupts(uint32_t nvicPriority) {
      \t   enableNvicInterrupt(Info::irqNums[Info::MessageBuffer_0_15_IrqNumIndex], nvicPriority);
      \t   enableNvicInterrupt(Info::irqNums[Info::MessageBuffer_16_32_IrqNumIndex], nvicPriority);
      \t}
      \t
      \t/**
      \t * Disable Message Buffer interrupts in NVIC
      \t */
      \tstatic void disableMessageBufferNvicInterrupts() {
      \t   NVIC_DisableIRQ(Info::irqNums[Info::MessageBuffer_0_15_IrqNumIndex]);
      \t   NVIC_DisableIRQ(Info::irqNums[Info::MessageBuffer_0_15_IrqNumIndex]);
      \t}\n\n
   ]]></template>

   <xi:include href="_clockOption.xml"/>
      
   <projectActionList id = "can_files" >
      <copy source="Project_Headers/can.h"                    target="Project_Headers/can.h"                    overwrite="true"  derived="true" />
   </projectActionList>
   
</peripheralPage>
