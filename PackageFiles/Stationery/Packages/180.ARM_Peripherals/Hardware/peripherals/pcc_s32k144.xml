<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- pdb0_1ch_2pt_0dac_2po.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Port Clock Control" >

      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Clock sources using first dividers\n\n
         \t * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
         \t * - SIRC_CLK = Output clock of Slow IRC.
         \t * - FIRC_CLK = Output clock of Fast IRC.
         \t * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
         \t */
         \tenum Div1ClockSource {
         \t   Div1ClockSource_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
         \t   Div1ClockSource_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
         \t   Div1ClockSource_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SPLLDIV[SOSCDIV1]
         \t   Div1ClockSource_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[FIRCDIV1]
         \t   Div1ClockSource_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV1]
         \t   Div1ClockSource_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
         \t   Div1ClockSource_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
         \t   Div1ClockSource_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV1]
         \t   Div1ClockSource_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
         \t};\n\n
      
         \t/**
         \t * Clock sources using second dividers\n\n
         \t * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
         \t * - SIRC_CLK = Output clock of Slow IRC.
         \t * - FIRC_CLK = Output clock of Fast IRC (Nominally 48MHz).
         \t * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
         \t */
         \tenum Div2ClockSource {
         \t   Div2ClockSource_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
         \t   Div2ClockSource_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
         \t   Div2ClockSource_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SPLLDIV[SOSCDIV2]
         \t   Div2ClockSource_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[FIRCDIV2]
         \t   Div2ClockSource_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV2]
         \t   Div2ClockSource_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
         \t   Div2ClockSource_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
         \t   Div2ClockSource_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV2]
         \t   Div2ClockSource_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Get clock frequency for peripheral using the Divide-by-1 clock sources
         \t *
         \t * @param div1ClockSource Clock source selector as used by PCC->PCCn
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getDivideBy1Clock(Div1ClockSource div1ClockSource) {
         \t   switch(div1ClockSource&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         \t      default:
         \t      case Div1ClockSource_Disabled: return 0; // Disabled
         \t      case Div1ClockSource_Spll:     return ScgInfo::getSoscDiv1Clock(); // SPLLDIV1
         \t      case Div1ClockSource_Firc:     return ScgInfo::getFircDiv1Clock(); // FIRCDIV1
         \t      case Div1ClockSource_Sirc:     return ScgInfo::getSircDiv1Clock(); // SIRCDIV1
         \t      case Div2ClockSource_Sosc:     return ScgInfo::getSoscDiv1Clock(); // SOSCDIV2
         \t   }
         \t}\n\n

         \t/**
         \t * Get clock frequency for peripheral using the Divide-by-2 clock sources
         \t *
         \t * @param div2ClockSource Clock source selector as used by PCC->PCCn
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getDivideBy2Clock(Div2ClockSource div2ClockSource) {
         \t   switch(div2ClockSource&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         \t      default:
         \t      case Div2ClockSource_Disabled: return 0; // Disabled
         \t      case Div2ClockSource_Spll:     return ScgInfo::getSoscDiv2Clock(); // SPLLDIV2
         \t      case Div2ClockSource_Firc:     return ScgInfo::getFircDiv2Clock(); // FIRCDIV2
         \t      case Div2ClockSource_Sirc:     return ScgInfo::getSircDiv2Clock(); // SIRCDIV2
         \t      case Div2ClockSource_Sosc:     return ScgInfo::getSoscDiv2Clock(); // SOSCDIV2
         \t   }
         \t}\n\n
      ]]></template>
      
      <template>
         <for 
	    var="instance" 
	    enumeration="
           Adc0, Adc1, 
           Flexio, 
           Lpuart0, Lpuart1, Lpuart2, 
           Lpspi0, Lpspi1, Lpspi2, 
           Lpi2c0, Lpi2c1, Lpi2c2, 
           Lpit,
           Lptmr0"
         />
         <![CDATA[
         #ifdef PCC_PCC_$(instance::toupper)_CGC_MASK
         \t/**
         \t * Set $(instance::toupper) input clock source
         \t *
         \t * @param div2ClockSource Clock source selection
         \t */
         \tstatic void set$(instance)Clock(Div2ClockSource div2ClockSource) {
         \t   pcc().PCC_$(instance::toupper) = 0;
         \t   pcc().PCC_$(instance::toupper) = div2ClockSource;
         \t}\n\n
         
         \t/**
         \t * Get $(instance::toupper) input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t get$(instance)Clock() {
         \t   return getDivideBy2Clock((Div2ClockSource)pcc().PCC_$(instance::toupper));
         \t}\n
         #endif\n\n
         ]]>
      </template>
      
      <template>
         <for 
	    var="instance" 
	    enumeration="
           Ftm0, Ftm1, Ftm2, Ftm3, 
           Enet"
         />
         <![CDATA[
         #ifdef PCC_PCC_$(instance::toupper)_CGC_MASK
         \t/**
         \t * Set $(instance::toupper) input clock source
         \t *
         \t * @param div2ClockSource Clock source selection
         \t */
         \tstatic void set$(instance)Clock(Div1ClockSource div1ClockSource) {
         \t   pcc().PCC_$(instance::toupper) = 0;
         \t   pcc().PCC_$(instance::toupper) = div1ClockSource;
         \t}\n\n
         
         \t/**
         \t * Get $(instance::toupper) input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t get$(instance)Clock() {
         \t   return getDivideBy1Clock((Div1ClockSource)pcc().PCC_$(instance::toupper));
         \t}\n
         #endif\n\n
         ]]>
      </template>
      
</peripheralPage>
