<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- pdb0_1ch_2pt_0dac_2po.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Port Clock Control" >

      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Clock sources using first dividers\n\n
         \t * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
         \t * - SIRC_CLK = Output clock of Slow IRC.
         \t * - FIRC_CLK = Output clock of Fast IRC.
         \t * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
         \t */
         \tenum PccDiv1Clock {
         \t   PccDiv1Clock_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
         \t   PccDiv1Clock_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
         \t   PccDiv1Clock_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SOSCDIV[SOSCDIV1]
         \t   PccDiv1Clock_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[SIRCDIV1]
         \t   PccDiv1Clock_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV1]
         \t   PccDiv1Clock_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
         \t   PccDiv1Clock_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
         \t   PccDiv1Clock_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV1]
         \t   PccDiv1Clock_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
         \t};\n\n
      
         \t/**
         \t * Clock sources using second dividers\n\n
         \t * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
         \t * - SIRC_CLK = Output clock of Slow IRC.
         \t * - FIRC_CLK = Output clock of Fast IRC (Nominally 48MHz).
         \t * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
         \t */
         \tenum PccDiv2Clock {
         \t   PccDiv2Clock_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
         \t   PccDiv2Clock_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
         \t   PccDiv2Clock_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SOSCDIV[SOSCDIV2]
         \t   PccDiv2Clock_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[SIRCDIV2]
         \t   PccDiv2Clock_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV2]
         \t   PccDiv2Clock_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
         \t   PccDiv2Clock_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
         \t   PccDiv2Clock_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV2]
         \t   PccDiv2Clock_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Get clock frequency for peripheral using the Divide-by-1 clock sources
         \t *
         \t * @param pccDiv1Clock Clock source selector as used by PCC->PCCn
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getDivideBy1Frequency(PccDiv1Clock pccDiv1Clock) {
         \t   switch(pccDiv1Clock&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         \t      default:
         \t      case PccDiv1Clock_Disabled: return 0; // Disabled
         \t      case PccDiv1Clock_Spll:     return ScgInfo::getSoscDiv1Frequency(); // SPLLDIV1
         \t      case PccDiv1Clock_Firc:     return ScgInfo::getFircDiv1Frequency(); // FIRCDIV1
         \t      case PccDiv1Clock_Sirc:     return ScgInfo::getSircDiv1Frequency(); // SIRCDIV1
         \t      case PccDiv2Clock_Sosc:     return ScgInfo::getSoscDiv1Frequency(); // SOSCDIV2
         \t   }
         \t}\n\n

         \t/**
         \t * Get clock frequency for peripheral using the Divide-by-2 clock sources
         \t *
         \t * @param pccDiv2Clock Clock source selector as used by PCC->PCCn
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getDivideBy2Frequency(PccDiv2Clock pccDiv2Clock) {
         \t   switch(pccDiv2Clock&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         \t      default:
         \t      case PccDiv2Clock_Disabled: return 0; // Disabled
         \t      case PccDiv2Clock_Spll:     return ScgInfo::getSoscDiv2Frequency(); // SPLLDIV2
         \t      case PccDiv2Clock_Firc:     return ScgInfo::getFircDiv2Frequency(); // FIRCDIV2
         \t      case PccDiv2Clock_Sirc:     return ScgInfo::getSircDiv2Frequency(); // SIRCDIV2
         \t      case PccDiv2Clock_Sosc:     return ScgInfo::getSoscDiv2Frequency(); // SOSCDIV2
         \t   }
         \t}\n\n
      ]]></template>
      
      <template>
         <for 
	    var="instance" 
	    enumeration="
           Adc0, Adc1, 
           Flexio, 
           Lpuart0, Lpuart1, Lpuart2, 
           Lpspi0, Lpspi1, Lpspi2, 
           Lpi2c0, Lpi2c1, Lpi2c2, 
           Lpit,
           Lptmr0"
         />
         <![CDATA[
         #ifdef PCC_PCC_$(instance::toupper)_CGC_MASK
         \t/**
         \t * Set $(instance::toupper) input clock source
         \t *
         \t * @param pccDiv2Clock Clock source selection
         \t */
         \tstatic void set$(instance)Source(PccDiv2Clock pccDiv2Clock) {
         \t   pcc().PCC_$(instance::toupper) = 0;
         \t   pcc().PCC_$(instance::toupper) = pccDiv2Clock;
         \t}\n\n
         
         \t/**
         \t * Get $(instance::toupper) input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t get$(instance)Frequency() {
         \t   return getDivideBy2Frequency((PccDiv2Clock)pcc().PCC_$(instance::toupper));
         \t}\n
         #endif\n\n
         ]]>
      </template>
      
      <template>
         <for 
	    var="instance" 
	    enumeration="
           Ftm0, Ftm1, Ftm2, Ftm3, 
           Enet"
         />
         <![CDATA[
         #ifdef PCC_PCC_$(instance::toupper)_CGC_MASK
         \t/**
         \t * Set $(instance::toupper) input clock source
         \t *
         \t * @param pccDiv2Clock Clock source selection
         \t */
         \tstatic void set$(instance)Source(PccDiv1Clock pccDiv1Clock) {
         \t   pcc().PCC_$(instance::toupper) = 0;
         \t   pcc().PCC_$(instance::toupper) = pccDiv1Clock;
         \t}\n\n
         
         \t/**
         \t * Get $(instance::toupper) input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t get$(instance)Frequency() {
         \t   return getDivideBy1Frequency((PccDiv1Clock)pcc().PCC_$(instance::toupper));
         \t}\n
         #endif\n\n
         ]]>
      </template>
      
</peripheralPage>
