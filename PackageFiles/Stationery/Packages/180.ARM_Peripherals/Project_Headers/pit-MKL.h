/**
 * @file      pit.h  (180.ARM_Peripherals/Project_Headers/pit-MKL.h)
 *
 * @brief    Programmable Interrupt Timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef INCLUDE_USBDM_PIT_H_
#define INCLUDE_USBDM_PIT_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "system.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
/**
 * Type definition for PIT interrupt call back
 */
typedef void (*PitCallbackFunction)(void);

/**
 * Control PIT operation in debug mode (suspended for debugging)
 */
enum PitDebugMode {
   PitDebugMode_Run  = PIT_MCR_FRZ(0),  //!< PIT continues to run in debug mode
   PitDebugMode_Stop = PIT_MCR_FRZ(1),  //!< PIT stops in debug mode
};

/**
 * Enable the PIT interrupts
 */
enum PitChannelIrq {
   PitChannelIrq_Disabled  = PIT_TCTRL_TIE(0),  //!< PIT channel interrupt disabled
   PitChannelIrq_Enabled   = PIT_TCTRL_TIE(1),  //!< PIT channel interrupt disabled
};

/**
 * Enable the PIT channel
 */
enum PitChannelEnable {
   PitChannelEnable_Disabled  = PIT_TCTRL_TEN(0),  //!< PIT channel disabled
   PitChannelEnable_Enabled   = PIT_TCTRL_TEN(1),  //!< PIT channel enabled
};

/**
 * @brief Class representing a Programmable Interrupt  Timer
 *
 * <b>Example</b>
 * @code
 *
 * @endcode
 */
template<class Info>
class PitBase_T {

private:
   /**
    * This class is not intended to be instantiated
    */
   PitBase_T() = delete;
   PitBase_T(const PitBase_T&) = delete;
   PitBase_T(PitBase_T&&) = delete;

protected:
   /** Default TCTRL value for timer channel */
   static constexpr uint32_t PIT_TCTRL_DEFAULT_VALUE = (PIT_TCTRL_TEN_MASK);

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   
public:
   /**
    * Enable/disable channel interrupts
    *
    * @param[in]  channel Channel being modified
    * @param[in]  enable  True => enable, False => disable
    */
   static void enableInterrupts(unsigned channel, bool enable=true) {
      if (enable) {
         pit().CHANNEL[channel].TCTRL |= PIT_TCTRL_TIE_MASK;
      }
      else {
         pit().CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TIE_MASK;
      }
   }

   /** PIT interrupt handler -  Calls PIT callback */
   static void irqHandler() {
      for (unsigned channel=0; channel<Info::numChannels; channel++) {
         if (pit().CHANNEL[channel].TFLG & PIT_TFLG_TIF_MASK) {
            // Clear interrupt flag
            pit().CHANNEL[channel].TFLG = PIT_TFLG_TIF_MASK;
            // Do call-back
            callbacks[channel]();
         }
      }
   }

   /**
    * Set interrupt callback
    *
    *  @param[in]  channel           Channel to configure
    *  @param[in]  callbackFunction  Function to call from stub ISR
    */
   static void setCallback(uint8_t channel, PitCallbackFunction callbackFunction) {
      if (callbackFunction == nullptr) {
         callbackFunction = unhandledCallback;
         enableInterrupts(channel, false);
      }
      callbacks[channel] = callbackFunction;
   }

protected:
   /** Pointer to hardware */
   static __attribute__((always_inline)) volatile PIT_Type &pit()      { return Info::pit(); }

   /** Pointer to clock register */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

public:
   /**
    * Basic enable of PIT
    */
   static void enable() {
      // Enable clock
      clockReg() |= Info::clockMask;
      __DMB();
   }

   /**
    *  Enable the PIT with default settings.
    *  All channels are enabled with default settings.
    */
   static void defaultConfigure() {
      enable();

      // Enable timer
      pit().MCR = Info::mcr;

      enableNvicInterrupts();
   }

   /**
    *  Enables and configures the PIT
    *
    *  @param[in]  pitDebugMode  Determined whether the PIT halts when suspended during debug
    */
   static void configure(PitDebugMode pitDebugMode=PitDebugMode_Stop) {
      enable();
      pit().MCR = pitDebugMode|PIT_MCR_MDIS(0); // MDIS cleared => enabled!
   }

   /**
    *   Disable the PIT (all channels)
    */
   static void disable() {
      pit().MCR = PIT_MCR_MDIS(1);
      clockReg() &= ~Info::clockMask;
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param[in]  enable        True => enable, False => disable
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @return E_NO_ERROR on success
    */
   static ErrorCode enableNvicInterrupts(bool enable=true, uint32_t nvicPriority=NvicPriority_Normal) {

      constexpr IRQn_Type irqNum = Info::irqNums[0];
      if (enable) {
         enableNvicInterrupt(irqNum, nvicPriority);
      }
      else {
         NVIC_DisableIRQ(irqNum);
      }
      return E_NO_ERROR;
   }
   
   /**
    *  Enable the PIT channel
    *
    *  @param[in]  channel   Channel to enable
    */
   static void enableChannel(const uint8_t channel) {
      pit().CHANNEL[channel].TCTRL |= PIT_TCTRL_TEN_MASK;
   }

   /**
    *   Disable the PIT channel
    *
    *   @param[in]  channel Channel to disable
    */
   static void disableChannel(uint8_t channel) {

      // Disable timer channel
      pit().CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TEN_MASK;
   }

   /**
    *  Configure the PIT channel
    *
    *  @param[in]  channel           Channel to configure
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    *  @param[in]  pitChannelIrq     Whether to enable interrupts
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInTicks(
         uint8_t           channel,
         uint32_t          tickInterval,
         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) {

      usbdm_assert(tickInterval>0, "Interval too short");

      pit().CHANNEL[channel].TCTRL = 0;
      pit().CHANNEL[channel].LDVAL = tickInterval-1;
      pit().CHANNEL[channel].TFLG  = PIT_TFLG_TIF_MASK;
      pit().CHANNEL[channel].TCTRL = pitChannelIrq|PIT_TCTRL_TEN(1);
   }

   /**
    *  Configure the PIT channel
    *
    *  @param[in]  channel           Channel to configure
    *  @param[in]  intervalInSeconds Interval in seconds
    *  @param[in]  pitChannelIrq     Whether to enable interrupts
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         uint8_t           channel,
         float             intervalInSeconds,
         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) {

      configureChannelInTicks(channel, convertSecondsToTicks(intervalInSeconds), pitChannelIrq);
   }

   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time interval in ticks
    *
    * @return Time interval in seconds
    */
   static float convertTicksToSeconds(uint32_t timeInTicks) {
      return ((float)timeInTicks)/Info::getClockFrequency();
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] time Time interval in seconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static int convertSecondsToTicks(float seconds) {
      float intervalInTicks = rintf(seconds*Info::getClockFrequency());
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return rintf((uint32_t)intervalInTicks);
   }

   /**
    * Set period in seconds
    *
    * @param[in]  channel Channel being modified
    * @param[in]  interval Interval in ticks
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInTicks(unsigned channel, uint32_t interval) {
      pit().CHANNEL[channel].LDVAL = interval-1;
   }

   /**
    * Set period in seconds
    *
    * @param[in]  channel Channel being modified
    * @param[in]  interval Interval in seconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(unsigned channel, float interval) {
      setPeriodInTicks(channel, rintf(interval*Info::getClockFrequency()));
   }

   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  channel   Channel to use
    *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delayInTicks(uint8_t channel, uint32_t interval) {
      configureChannelInTicks(channel, interval);
      while (pit().CHANNEL[channel].TFLG == 0) {
         __NOP();
      }
      disableChannel(channel);
   }

   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  channel   Channel to use
    *  @param[in]  interval  Interval to wait as a float
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(uint8_t channel, float interval) {
      configureChannel(channel, interval);
      while (pit().CHANNEL[channel].TFLG == 0) {
         __NOP();
      }
      disableChannel(channel);
   }

protected:
   /** Callback functions for ISRs */
   static PitCallbackFunction callbacks[Info::numChannels];

   /**
    * Class representing a PIT channel
    *
    * @tparam channel Timer channel number
    */
   template <int channel>
   class Channel {

   public:
      /** Timer channel number */
      static constexpr int CHANNEL = channel;

      /**
       * Set interrupt callback
       *
       * @param[in]  callbackFunction  Function to call from stub ISR
       */
      static void setCallback(PitCallbackFunction callbackFunction) {
         PitBase_T<Info>::setCallback(channel, callbackFunction);
      }

      /** PIT interrupt handler - Calls PIT callback */
      static void irqHandler() {
         // Clear interrupt flag
         PitBase_T<Info>::pit().CHANNEL[channel].TFLG = PIT_TFLG_TIF_MASK;
         callbacks[channel]();
      }

      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in timer ticks (usually bus clock)
       *  @param[in]  pitChannelIrq     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void __attribute__((always_inline)) configureInTicks(
            uint32_t          interval,
            PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) {

         PitBase_T<Info>::configureChannelInTicks(channel, interval, pitChannelIrq);
      }

      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in seconds
       *  @param[in]  pitChannelIrq     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void __attribute__((always_inline)) configure(
            float             interval,
            PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) {

         PitBase_T<Info>::configureChannel(channel, interval, pitChannelIrq);
      }

      /**
       * Set period in seconds
       *
       * @param[in]  interval Interval in seconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void __attribute__((always_inline)) setPeriod(float interval) {
         PitBase_T<Info>::setPeriod(channel, interval);
      }

      /**
       * Set period in ticks
       *
       * @param[in]  interval Interval in ticks
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void __attribute__((always_inline)) setPeriodInTicks(uint32_t interval) {
         PitBase_T<Info>::setPeriodInTicks(channel, interval);
      }

      /**
       *   Enable the PIT channel
       */
      static void __attribute__((always_inline)) enable() {
         PitBase_T<Info>::enableChannel(channel);
      }

      /**
       *   Disable the PIT channel
       */
      static void __attribute__((always_inline)) disable() {
         PitBase_T<Info>::disableChannel(channel);
      }

      /**
       * Enable/disable channel interrupts.
       *
       * @param[in]  enable  True => enable, False => disable
       *
       * @note It is also necessary to modify NVIC using enableNvicInterrupts().
       */
      static void __attribute__((always_inline)) enableInterrupts(bool enable=true) {
         PitBase_T<Info>::enableInterrupts(channel, enable);
      }

      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
       *
       *  @note Function doesn't return until interval has expired
       */
      static void __attribute__((always_inline)) delayInTicks(uint32_t interval) {
         PitBase_T<Info>::delayInTicks(channel, interval);
      }

      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait as a float
       *
       *  @note Function doesn't return until interval has expired
       */
      static void __attribute__((always_inline)) delay(float interval) {
         PitBase_T<Info>::delay(channel, interval);
      }
   };
};

/**
 * Callback table for programmatically set handlers
 */
template<class Info>
PitCallbackFunction PitBase_T<Info>::callbacks[] = {
      PitBase_T<Info>::unhandledCallback,
      PitBase_T<Info>::unhandledCallback,
};

#ifdef PIT
/**
 * @brief class representing the PIT
 */
using Pit = PitBase_T<PitInfo>;

/**
 * @brief Class representing a PIT channel
 *
 * @tparam channel Channel number
 */
template <int channel>
using PitChannel = Pit::Channel<channel>;

#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_PIT_H_ */
