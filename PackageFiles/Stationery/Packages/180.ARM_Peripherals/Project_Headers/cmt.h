/**
 * @file     cmt.h (180.ARM_Peripherals/Project_Headers/cmt.h)
 * @brief    Voltage Comparator
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_CMT_H_
#define HEADER_CMT_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief Pins used for Carrier Modulator Transmitter
 * @{
 */

/**
 *
 */
enum CmtClockDivideBy {
   CmtClockDivideBy_1 = CMT_MSC_CMTDIV(0),//!< CmtClockDivideBy_1
   CmtClockDivideBy_2 = CMT_MSC_CMTDIV(1),//!< CmtClockDivideBy_2
   CmtClockDivideBy_4 = CMT_MSC_CMTDIV(2),//!< CmtClockDivideBy_4
   CmtClockDivideBy_6 = CMT_MSC_CMTDIV(3),//!< CmtClockDivideBy_6
};

/**
 *
 */
enum CmtPrescaler {
   CmtPrescaler_1     = CMT_PPS_PPSDIV(0), //!< CmtPrescaler_1
   CmtPrescaler_2     = CMT_PPS_PPSDIV(1), //!< CmtPrescaler_2
   CmtPrescaler_3     = CMT_PPS_PPSDIV(2), //!< CmtPrescaler_3
   CmtPrescaler_4     = CMT_PPS_PPSDIV(3), //!< CmtPrescaler_4
   CmtPrescaler_5     = CMT_PPS_PPSDIV(4), //!< CmtPrescaler_5
   CmtPrescaler_6     = CMT_PPS_PPSDIV(5), //!< CmtPrescaler_6
   CmtPrescaler_7     = CMT_PPS_PPSDIV(6), //!< CmtPrescaler_7
   CmtPrescaler_8     = CMT_PPS_PPSDIV(7), //!< CmtPrescaler_8
   CmtPrescaler_9     = CMT_PPS_PPSDIV(8), //!< CmtPrescaler_9
   CmtPrescaler_10    = CMT_PPS_PPSDIV(9), //!< CmtPrescaler_10
   CmtPrescaler_11    = CMT_PPS_PPSDIV(10),//!< CmtPrescaler_11
   CmtPrescaler_12    = CMT_PPS_PPSDIV(11),//!< CmtPrescaler_12
   CmtPrescaler_13    = CMT_PPS_PPSDIV(12),//!< CmtPrescaler_13
   CmtPrescaler_14    = CMT_PPS_PPSDIV(13),//!< CmtPrescaler_14
   CmtPrescaler_15    = CMT_PPS_PPSDIV(14),//!< CmtPrescaler_15
   CmtPrescaler_16    = CMT_PPS_PPSDIV(15),//!< CmtPrescaler_16
};

/**
 *
 */
enum CmtMode {
   CmtMode_Time            = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(0)|CMT_MSC_FSK(0)|CMT_MSC_EXSPC(0), //!< fcg from primary high & low
   CmtMode_Baseband        = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(1)|CMT_MSC_FSK(0)|CMT_MSC_EXSPC(0), //!< fcg always high
   CmtMode_FreqShiftKeying = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(0)|CMT_MSC_FSK(1)|CMT_MSC_EXSPC(0), //!< fcg alternates between primary/secondary high & low
   CmtMode_ExtendedSpace   = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(0)|CMT_MSC_FSK(0)|CMT_MSC_EXSPC(1), //!< forces subsequent to be spaces
   CmtMode_Direct          = CMT_MSC_MCGEN(0)|CMT_MSC_BASE(0)|CMT_MSC_FSK(0)|CMT_MSC_EXSPC(0), //!< OC[IROL] controls IRO
};

/**
 *
 */
enum CmtOutput {
   CmtOutput_Disable = CMT_OC_IROPEN(0), //!< IRO Pin disabled
   CmtOutput_Enable  = CMT_OC_IROPEN(1), //!< IRO Pin enabled
};

/**
 *
 */
enum CmtPolarity {
   CmtPolarity_ActiveLow  = CMT_OC_CMTPOL(0), //!< Active low
   CmtPolarity_ActiveHigh = CMT_OC_CMTPOL(1), //!< Active high
};

/**
 *
 */
enum CmtInterrupt {
   CmtInterrupt_Disable = CMT_MSC_EOCIE(0),  //!< Interrupts disabled
   CmtInterrupt_Enable  = CMT_MSC_EOCIE(1),  //!< Interrupts enabled

};

/**
 * Type definition for CMT interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*CMTCallbackFunction)();

/**
 * Template class representing a Carrier Modulator Transmitter
 *
 * @tparam info      Information class for CMT
 *
 */
template<class Info>
class CmtBase_T {

protected:
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledChannelCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static CMTCallbackFunction callback;

   /**
    * Clock register for peripheral
    *
    * @return Reference to clock register
    */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static __attribute__((always_inline)) volatile CMT_Type &cmt() { return Info::cmt(); }

   /**
    * IRQ handler
    */
   static void irqHandler() {

      // Call handler
      callback();
   }

   /**
    * Set callback function
    *
    * @param[in]  theCallback Callback function to execute on interrupt
    */
   static void setCallback(CMTCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         theCallback = unhandledChannelCallback;
      }
      callback = theCallback;
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Basic enable CMT.
    * Includes enabling clock and configuring all pins of mapPinsOnEnable is selected on configuration
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to CMP interface
      clockReg() |= Info::clockMask;
   }

   /**
    *
    * @param cmtPrescaler
    */
   static void setPrescaler(CmtPrescaler cmtPrescaler) {
      cmt().PPS = cmtPrescaler;
   }

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Initialise hardware
   }

   /**
    * Enable CMT output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding MUX value). See pcrValue()
    */
   static void setOutput(PcrValue pcrValue=Info::defaultPcrValue) {
      using Pcr = PcrTable_T<Info, 0>;

      // Enable and map pin to CMP_OUT
      Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[0].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Enable CMT output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
         ) {
      setOutput(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /**
    * Base configuration
    *
    * @param cmtMode
    * @param cmtClockDivideBy
    * @param cmtInterrupt
    */
   static void configure(CmtMode cmtMode, CmtClockDivideBy cmtClockDivideBy=CmtClockDivideBy_1, CmtInterrupt cmtInterrupt=CmtInterrupt_Disable) {
      enable();
      setPrescaler((CmtPrescaler)((USBDM::SystemBusClock/8000000)-1));
      cmt().MSC = cmtMode|cmtClockDivideBy|cmtInterrupt;
   }

   /**
    *
    * @param cmtOutput
    * @param cmtPolarity
    */
   static void outputControl(CmtOutput cmtOutput, CmtPolarity cmtPolarity=CmtPolarity_ActiveHigh) {
      cmt().OC = cmtOutput|cmtPolarity;
   }

   /**
    *
    * @param cmtMode
    */
   static void setMode(CmtMode cmtMode) {
      cmt().MSC = (cmt().MSC&~(CMT_MSC_MCGEN(1)|CMT_MSC_BASE(1)|CMT_MSC_FSK(1)|CMT_MSC_EXSPC(1)))|cmtMode;
   }

   /**
    *
    * @param high
    * @param low
    */
   static void setPrimaryTiming(uint8_t high, uint8_t low) {
      cmt().CGH1 = high;
      cmt().CGL1 = low;
   }

   /**
    *
    * @param high
    * @param low
    */
   static void setSecondaryTiming(uint8_t high, uint8_t low) {
      cmt().CGH2 = high;
      cmt().CGL2 = low;
   }

   /**
    *
    * @param mark
    * @param space
    */
   static void setMarkSpaceTiming(uint32_t mark, uint32_t space) {
      cmt().CMD1 = (uint8_t)(mark>>8);
      cmt().CMD2 = (uint8_t)(mark);
      cmt().CMD3 = (uint8_t)(space>>8);
      cmt().CMD4 = (uint8_t)(space);
    }

   /**
    *
    * @param enable
    */
   static void enableDma(bool enable) {
      if (enable) {
         cmt().DMA = CMT_DMA_DMA(1);
      }
      else {
         cmt().DMA = CMT_DMA_DMA(0);
      }
   }
};

template<class Info> CMTCallbackFunction CmtBase_T<Info>::callback = CmtBase_T<Info>::unhandledChannelCallback;

#if defined(USBDM_CMT_IS_DEFINED)
class Cmt : public CmtBase_T<CmtInfo> {};
#endif

#if defined(USBDM_CMT1_IS_DEFINED)
class Cmt1 : public CmtBase_T<Cmt1Info> {};
#endif

#if defined(USBDM_CMT2_IS_DEFINED)
class Cmt2 : public CmtBase_T<Cmt2Info> {};
#endif

/**
 * End CMT_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMT_H_ */
