/*
 * dma.h  (180.ARM_Peripherals/Project_Headers/dma-MK.h)
 *
 *  Created on: 08/07/2014
 *      Author: podonoghue
 */

#ifndef INCLUDE_USBDM_DMA_H_
#define INCLUDE_USBDM_DMA_H_

#include "derivative.h"
#include "hardware.h"
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
namespace USBDM {

enum DmaMuxEnable {
   DmaMuxEnable_Disable    = DMAMUX_CHCFG_ENBL(0),                      //!< DMA channel is disabled
   DmaMuxEnable_Continuous = DMAMUX_CHCFG_ENBL(1)|DMAMUX_CHCFG_TRIG(0), //!< DMA channel is enabled
   DmaMuxEnable_Triggered  = DMAMUX_CHCFG_ENBL(1)|DMAMUX_CHCFG_TRIG(1), //!< DMA channel is triggered by PIT channel
};

class DmaMux0 : public Dmamux0Info {

   // Pointer to hardware
//   static constexpr volatile DMAMUX_Type *dmacmux = dmamux;

public:

   /**
    * Configures and enable hardware requests on channel
    *
    * @param[in] dmaChannel   The DMA channel being enabled
    * @param[in] dmaSlot      The DMA slot (source) to connect to this channel
    * @param[in] dmaMuxEnable The mode for the channel
    */
   static void configure(int dmaChannel, DmaSlot dmaSlot, DmaMuxEnable dmaMuxEnable=DmaMuxEnable_Continuous) {
#ifdef DEBUG_BUILD
      // PIT triggering only available on 1st 4 channels
      assert ((dmaMuxEnable != DmaMuxEnable_Triggered) || (dmaChannel<=4));
#endif
      // Enable clock to peripheral
      *clockReg  |= clockMask;

      // Configure channel
      dmamux->CHCFG[dmaChannel] = dmaMuxEnable|DMAMUX_CHCFG_SOURCE(dmaSlot);
   }
   /**
    * Disable hardware requests on channel
    */
   static void disable(int dmaChannel) {
      // Enable clock to peripheral
      *clockReg  |= clockMask;
      // Disable channel
      dmamux->CHCFG[dmaChannel] = 0;
   }
};

enum DmaSize {
   DmaSize_8bit    = 0,  //!< 8-bit transfer
   DmaSize_16bit   = 1,  //!< 16-bit transfer
   DmaSize_32bit   = 2,  //!< 32-bit transfer
   DmaSize_16byte  = 4,  //!< 16-byte transfer
   DmaSize_32byte  = 5,  //!< 32-byte transfer
   DmaSize_Illegal = 7,  //!< Illegal transfer
};

/**
 * @addtogroup DMA_Group Direct Memory Access (DMA)
 * @brief Support for DMA operations
 * @{
 */
class DmaChannel {
public:
   /**
    * Get DMA size from object size
    *
    * @param[in] size
    *
    * @return one of the DmaSize_xxxx values
    */
   static constexpr DmaSize getAttrSize(uint size) {
      return
         (size==1) ?DmaSize_8bit:
         (size==2) ?DmaSize_16bit:
         (size==4) ?DmaSize_32bit:
         (size==16)?DmaSize_16byte:
         (size==32)?DmaSize_32byte:
               DmaSize_Illegal;
   };

   struct Tcd {
      __IO uint32_t  SADDR;                     //!< Source Address
      __IO uint16_t  SOFF;                      //!< Signed Source Address Offset
      __IO uint16_t  ATTR;                      //!< Transfer Attributes
      union {                                   //!< (size=0004)
         __IO uint32_t  NBYTES_MLNO;            //!< Minor Byte Count (Minor Loop Disabled)
         __IO uint32_t  NBYTES_MLOFFNO;         //!< Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
         __IO uint32_t  NBYTES_MLOFFYES;        //!< Signed Minor Loop Offset (Minor Loop and Offset Enabled)
      };
      __IO uint32_t  SLAST;                     //!< Last Source Address Adjustment
      __IO uint32_t  DADDR;                     //!< Destination Address
      __IO uint16_t  DOFF;                      //!< Signed Destination Address Offset
      union {                                   //!< (size=0002)
         __IO uint16_t  CITER_ELINKNO;          //!< Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
         __IO uint16_t  CITER_ELINKYES;         //!< Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
      };
      __IO uint32_t  DLASTSGA;                  //!< Last Destination Address Adjustment/Scatter Gather Address
      __IO uint16_t  CSR;                       //!< Control and Status
      union {                                   //!< (size=0002)
         __IO uint16_t  BITER_ELINKNO;          //!< Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
         __IO uint16_t  BITER_ELINKYES;         //!< Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
      };
   };

   struct SingleTransferInfo {
      const volatile void *sourceAddress;          //!< Source Address
      volatile void       *destinationAddress;     //!< Destination Address
      uint32_t             nBytes;                 //!< Transfer Size in bytes - may include minor-loop offset
      uint16_t             attributes;             //!< Attributes - see DMA_ATTR_SMOD etc
      uint16_t             sourceOffset;           //!< Signed increment applied to source address after each transfer
      uint16_t             destinationOffset;      //!< Signed increment applied to destination address after each transfer
   };
   struct MultipleTransferInfo {
      const volatile void *sourceAddress;          //!< Source Address
      volatile void       *destinationAddress;     //!< Destination Address
      uint32_t             nBytes;                 //!< Transfer Size in bytes - may include minor-loop offset
      uint16_t             attributes;             //!< Attributes - see DMA_ATTR_SMOD etc
      uint16_t             sourceOffset;           //!< Signed increment applied to source address after each transfer
      uint16_t             destinationOffset;      //!< Signed increment applied to destination address after each transfer
      uint16_t             numberOfTransactions;   //!< Number of transactions
   };
};

/**
 * @addtogroup DMA_Group Direct Memory Access (DMA)
 * @brief Support for DMA operations
 * @{
 */
/**
 * @tparam Info         Information for DMA channel
 * @tparam channel      DMA channel to use
 * @tparam dmaSource    Hardware DMA source e.g. UART0
 */
class Dma0 : public DmaChannel {

   using DmaInfo = Dma0Info;
   using MuxInfo = Dmamux0Info;

protected:
   // Pointer to hardware
   static constexpr volatile DMA_Type    *dmac          = DmaInfo::dma;
   // Pointer to clock register
   static constexpr volatile uint32_t    *clockReg      = DmaInfo::clockReg;
   // IRQ Num
   static constexpr IRQn_Type             irqNum        = DMA0_IRQn;

public:
   /**
    * Configure channel for a single transaction
    */
   static void configure(int channel, const SingleTransferInfo &information) {
      // Enable clock to peripheral
      *DmaInfo::clockReg  |= DmaInfo::clockMask;

      // ML-offset, Debug, RR priority
      dmac->CR       = DMA_CR_EMLM_MASK|DMA_CR_EDBG_MASK|DMA_CR_ERCA_MASK;

      // Enable hardware request
      dmac->SERQ     = channel;

      //      if (dmaSource>0) {
//         dmac->SERQ                     = channel; // Enable hardware request
//      }
//      else {
//         dmac->CERQ                     = channel;
//      }
      dmac->TCD[channel].CITER_ELINKNO  = 1;                                             // Single transaction
      dmac->TCD[channel].BITER_ELINKNO  = 1;                                             // Single transaction
      dmac->TCD[channel].NBYTES_MLNO    = information.nBytes;                            // Number of bytes to transfer
      dmac->TCD[channel].SADDR          = (uint32_t)information.sourceAddress;           // Source address
      dmac->TCD[channel].SOFF           = information.sourceOffset;                      // Increment for SADDR
      dmac->TCD[channel].ATTR           = information.attributes;                        // Attributes - see DMA_ATTR_SMOD etc
      dmac->TCD[channel].SLAST          = 0;                                             // No adjustment as single transfer
      dmac->TCD[channel].DADDR          = (uint32_t)information.destinationAddress;      // Destination address
      dmac->TCD[channel].DOFF           = information.destinationOffset;                 // Increment for DADDR
      dmac->TCD[channel].DLASTSGA       = 0;                                             // No adjustment as single transfer
      dmac->TCD[channel].CSR            = DMA_CSR_START_MASK|DMA_CSR_DREQ_MASK;
   }
   /**
    * Configure channel for a single transaction
    */
   static void configure(int channel, const MultipleTransferInfo &information) {
      *clockReg  |= MuxInfo::clockMask;

      // ML-offset, Debug, RR priority
      dmac->CR                          = DMA_CR_EMLM_MASK|DMA_CR_EDBG_MASK|DMA_CR_ERCA_MASK;

      // Enable hardware request
      dmac->SERQ                     = channel;

//      if (dmaSource>0) {
//         dmac->SERQ                     = channel; // Enable hardware request
//      }
//      else {
//         dmac->CERQ                     = channel;
//      }
      dmac->TCD[channel].CITER_ELINKNO  = information.numberOfTransactions;         // Number of transactions
      dmac->TCD[channel].BITER_ELINKNO  = information.numberOfTransactions;         // Number of transactions
      dmac->TCD[channel].NBYTES_MLNO    = information.nBytes;                       // Number of bytes to transfer
      dmac->TCD[channel].SADDR          = (uint32_t)information.sourceAddress;      // Source address
      dmac->TCD[channel].SOFF           = information.sourceOffset;                 // Increment for SADDR
      dmac->TCD[channel].ATTR           = information.attributes;                   // Attributes - see DMA_ATTR_SMOD etc
      dmac->TCD[channel].SLAST          = 0;                                        // No adjustment
      dmac->TCD[channel].DADDR          = (uint32_t)information.destinationAddress; // Destination address
      dmac->TCD[channel].DOFF           = information.destinationOffset;            // Increment for DADDR
      dmac->TCD[channel].DLASTSGA       = 0;                                        // No adjustment
      dmac->TCD[channel].CSR            = DMA_CSR_START_MASK;
   }
   /**
    * Waits until the channel indicates the transaction has completed
    */
   static void waitUntilComplete(int channel) {

      int lastCiter = dmac->TCD[channel].CITER_ELINKNO;
      while ((dmac->TCD[channel].CSR & DMA_CSR_DONE_MASK) == 0) {
         int currentCiter = dmac->TCD[channel].CITER_ELINKNO;
         if (lastCiter != currentCiter) {
            lastCiter = currentCiter;
            __asm__ volatile("nop");
         }
      }
   }
};

/**
 * @}
 */
} // End namespace USBDM

#endif /* INCLUDE_USBDM_DMA_H_ */
