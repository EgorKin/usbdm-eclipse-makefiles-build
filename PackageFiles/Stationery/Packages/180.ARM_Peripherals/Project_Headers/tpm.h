/**
 * @file     tpm.h (180.ARM_Peripherals/Project_Headers/tpm.h)
 * @brief    Flexitimer Timer Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_TPM_H
#define HEADER_TPM_H

 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include "derivative.h"
#include <cmath>

/*
 * Default port information
 */

#ifndef TPM0_CLOCK_MASK
#ifdef SIM_SCGC6_TPM0_MASK
#define TPM0_CLOCK_MASK SIM_SCGC6_TPM0_MASK
#define TPM0_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC6_TPM1_MASK
#define TPM1_CLOCK_MASK SIM_SCGC6_TPM1_MASK
#define TPM1_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC6_TPM2_MASK
#define TPM2_CLOCK_MASK SIM_SCGC6_TPM2_MASK
#define TPM2_CLOCK_REG  SCGC6
#elif defined SIM_SCGC3_TPM2_MASK
#define TPM2_CLOCK_MASK SIM_SCGC3_TPM2_MASK
#define TPM2_CLOCK_REG  SCGC3
#endif
#ifdef SIM_SCGC6_TPM3_MASK
#define TPM3_CLOCK_MASK SIM_SCGC6_TPM3_MASK
#define TPM3_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC3_TPM3_MASK
#define TPM3_CLOCK_MASK SIM_SCGC3_TPM3_MASK
#define TPM3_CLOCK_REG  SCGC3
#endif
#ifdef SIM_SCGC3_TPM3_MASKC
#define TPM3_CLOCK_MASK SIM_SCGC3_TPM3_MASKC
#define TPM3_CLOCK_REG  SCGC3
#endif
#endif

namespace USBDM {

/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 *  Control mode of operation of shared timer counter
 */
enum TpmMode {
   //! Up counter: Used for left-aligned PWM, input capture and output compare modes
   TpmMode_LeftAlign   = 0,
   //! Up-down counter: Used for centre-aligned PWM
   TpmMode_CentreAlign = TPM_SC_CPWMS_MASK,
   //! Dummy value: Used for quadrature encoder
   TpmMode_Quadrature  = 0,
};

/**
 * Controls basic operation of PWM/Input capture/Output compare
 */
enum TpmChMode {
   TpmChMode_Disabled                = TPM_CnSC_MS(0)|TPM_CnSC_ELS(0), //!< Channel disabled
   TpmChMode_InputCaptureRisingEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(1), //!< Capture rising edge
   TpmChMode_InputCaptureFallingEdge = TPM_CnSC_MS(0)|TPM_CnSC_ELS(2), //!< Capture falling edge
   TpmChMode_InputCaptureEitherEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(3), //!< Capture both rising and falling edges
   TpmChMode_OutputCompare           = TPM_CnSC_MS(1),                 //!< Output compare operation without pin action
   TpmChMode_OutputCompareToggle     = TPM_CnSC_MS(1)|TPM_CnSC_ELS(1), //!< Toggle pin on output compare
   TpmChMode_OutputCompareClear      = TPM_CnSC_MS(1)|TPM_CnSC_ELS(2), //!< Clear pin on output compare
   TpmChMode_OutputCompareSet        = TPM_CnSC_MS(1)|TPM_CnSC_ELS(3), //!< Set pin on output compare
   TpmChMode_PwmHighTruePulses       = TPM_CnSC_MS(2)|TPM_CnSC_ELS(2), //!< PWM with high-true pulses
   TpmChMode_PwmLowTruePulses        = TPM_CnSC_MS(2)|TPM_CnSC_ELS(1), //!< PWM with low-true pulses
};

/**
 * Control alignment of PWM function
 */
enum TpmClockSource {
   TpmClockSource_Disabled    = TPM_SC_CMOD(0),  //!< Timer is disabled
   TpmClockSource_Internal    = TPM_SC_CMOD(1),  //!< Internal clock (usually determined by SIM->TPMCLKSRC clock )
   TpmClockSource_External    = TPM_SC_CMOD(2),  //!< External clock provided to TPM_CLKINx pin
   TpmClockSource_Reserved    = TPM_SC_CMOD(3),  //!< Reserved
};

/**
 * Control Prescaler for TPM clock
 */
enum TpmPrescale {
   TpmPrescale_1   = TPM_SC_PS(0),  //!< Divide by 1
   TpmPrescale_2   = TPM_SC_PS(1),  //!< Divide by 2
   TpmPrescale_4   = TPM_SC_PS(2),  //!< Divide by 4
   TpmPrescale_8   = TPM_SC_PS(3),  //!< Divide by 8
   TpmPrescale_16  = TPM_SC_PS(4),  //!< Divide by 16
   TpmPrescale_32  = TPM_SC_PS(5),  //!< Divide by 32
   TpmPrescale_64  = TPM_SC_PS(6),  //!< Divide by 64
   TpmPrescale_128 = TPM_SC_PS(7),  //!< Divide by 128
};

/*
 * Enabled Timer interrupt or DMA
 */
enum TpmChannelAction {
   TpmChannelAction_None   = TPM_CnSC_CHIE(0), //!< No action on event
   TpmChannelAction_Irq    = TPM_CnSC_CHIE(1), //!< Interrupt on event
#ifdef TPM_CnSC_DMA
   TpmChannelAction_Dma    = TPM_CnSC_CHIE(0)|TPM_CnSC_DMA(1), //!< Dma on event
   TpmChannelAction_IrqDma = TPM_CnSC_CHIE(1)|TPM_CnSC_DMA(1), //!< Dma+Interrupt on event
#endif
};

/*
 * Enabled Timer interrupt
 */
enum TpmChannelIrq {
   TpmChannelIrq_Disable = TPM_CnSC_CHIE(0), //!< Disable interrupts from this channel
   TpmChannelIrq_Enable  = TPM_CnSC_CHIE(1), //!< Enable interrupts from this channel
};

#ifdef TPM_CnSC_DMA
/*
 * Enabled Timer DMA
 */
enum TpmChannelDma {
   TpmChannelDma_Disable = TPM_CnSC_DMA(0), //!< Disable DMA requests from this channel
   TpmChannelDma_Enable  = TPM_CnSC_DMA(1), //!< Enable DMA requests from this channel
};
#endif

/**
 * Type definition for timer overflow interrupt call back
 */
typedef void (*TpmCallbackFunction)();
/**
 * Type definition for channel interrupt call back
 *
 * @param[in] status Flags indicating interrupt source channel(s)
 */
typedef void (*TpmChannelCallbackFunction)(uint8_t status);

/**
 * Holder for unhandledCallback() functions
 */
class TpmBase {

protected:
   /**
    * Callback to catch unhandled interrupt
    *
    * @param mask Mask identifying channel
    */
   static void unhandledChannelCallback(uint8_t mask) {
      (void)mask;
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
};

/**
 * Base class representing a TPM
 *
 * Example
 * @code
 * // Using TPM0
 * using Tpm0 = USBDM::TpmBase_T<TPM0_Info)>;
 *
 * // Initialise PWM with initial alignment and default clock source
 * Tpm0::configure(TpmMode_LeftAlign);
 *
 * // Set timer period
 * Tpm0::setPeriod(500);
 * @endcode
 *
 * @tparam Info  Class describing TPM hardware instance
 */
template<class Info>
class TpmBase_T : public TpmBase{

private:
   /**
    * This class is not intended to be instantiated
    */
   TpmBase_T() = delete;
   TpmBase_T(const TpmBase_T&) = delete;
   TpmBase_T(TpmBase_T&&) = delete;

   /** Callback function for TOI ISR */
   static TpmCallbackFunction sToiCallback;

   /** Callback function for Channel Fault */
   static TpmCallbackFunction faultCallback;

   /** Callback function for Channel ISR */
   static TpmChannelCallbackFunction sChannelCallback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      if ((tmr().SC&(TPM_SC_TOF_MASK|TPM_SC_TOIE_MASK)) == (TPM_SC_TOF_MASK|TPM_SC_TOIE_MASK)) {
         // Clear TOI flag (w1c)
         tmr().SC |= TPM_SC_TOF_MASK;
         sToiCallback();
      }
      uint8_t status = tmr().STATUS;
      if (status) {
         // Clear flags for channel events being handled (w1c register if read)
         tmr().STATUS = status;
         sChannelCallback(status);
      }
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the TPM
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static void INLINE_RELEASE setTimerOverflowCallback(TpmCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         sToiCallback = unhandledCallback;
         return;
      }
      sToiCallback = theCallback;
   }
   /**
    * Set channel Callback function\n
    * Note that one callback is shared by all channels of the TPM
    *
    * @param[in] theCallback Callback function to execute on channel interrupt.\n
    *                        nullptr to indicate none
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note One channel event callback is shared by all channels of the timer.
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode INLINE_RELEASE setChannelCallback(TpmChannelCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         sChannelCallback = unhandledChannelCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across all channels. Check if callback already assigned
      if ((sChannelCallback != unhandledChannelCallback) && (sChannelCallback != theCallback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      sChannelCallback = theCallback;
      return E_NO_ERROR;
   }

public:
   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile TPM_Type &tmr() { return Info::tpm(); }

   /** Clock register for peripheral */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void INLINE_RELEASE configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Enables clock to peripheral and configures all pins
    */
   static void INLINE_RELEASE enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to peripheral
      clockReg() |= Info::clockMask;
      __DMB();
   }

   /**
    * Configure with settings from Configure.usbdmProject.\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Wait for disable so immediate effect
      while (tmr().SC) {
         tmr().SC = 0;
      }

      // Common registers
      tmr().CNT     = 0;
      tmr().MOD     = Info::modulo;
      tmr().SC      = Info::sc;

      enableNvicInterrupts();
   }

   /**
    * Enables clock to peripheral and configures all pins
    * Configures main operating settings for timer
    *
    * @param[in] tpmMode        Mode of operation
    * @param[in] tpmClockSource Clock source for timer
    * @param[in] tpmPrescale    Clock prescaler. Used to divide clock source before use
    */
   static void configure(
         TpmMode        tpmMode,
         TpmClockSource tpmClockSource = TpmClockSource_Internal,
         TpmPrescale    tpmPrescale    = TpmPrescale_128) {

      enable();
      // Wait for disable so immediate effect
      while (tmr().SC) {
         tmr().SC = 0;
      }
      tmr().SC  = tpmMode|tpmClockSource|tpmPrescale;
      tmr().MOD = Info::modulo;
   }

   /**
    * Check if TPM is enabled\n
    * Just check for clock enable and clock source selection
    *
    * @return True => enabled
    */
   static INLINE_RELEASE bool isEnabled() {
      return ((clockReg() & Info::clockMask) != 0) && ((tmr().SC & TPM_SC_CMOD_MASK) != 0);
   }

   /**
    * Set timer mode
    *
    * @param[in] tpmMode        Mode of operation
    *
    * @note This function will affect all channels of the timer.
    */
   static void setMode(TpmMode tpmMode=TpmMode_LeftAlign) {
      // Disable timer to allow change
      uint32_t sc = tmr().SC;
      // Wait for disable so immediate effect
      while (tmr().SC) {
         tmr().SC = 0;
      }
      tmr().SC = (sc&~TPM_SC_CPWMS_MASK)|tpmMode;
   }

   /**
    * Set timer clock source
    *
    * @param[in] tpmClockSource Clock source for timer
    *
    * @note This function will affect all channels of the timer.
    */
   static void setClockSource(TpmClockSource tpmClockSource=TpmClockSource_Internal) {
      // Disable timer to allow change
      uint32_t sc = tmr().SC;
      // Wait for disable so immediate effect
      while (tmr().SC) {
         tmr().SC = 0;
      }
      tmr().SC = (sc&~TPM_SC_CMOD_MASK)|tpmClockSource;
   }

   /**
    *  Set timer prescaler
    *
    * @param[in] tpmPrescale    Clock prescaler. Used to divide clock source before use
    *
    * @note This function will affect all channels of the timer.
    */
   static void setPrescaler(TpmPrescale tpmPrescale=TpmPrescale_128) {
      // Disable timer to allow change
      uint32_t sc = tmr().SC;
      // Wait for disable so immediate effect
      while (tmr().SC) {
         tmr().SC = 0;
      }
      tmr().SC = (sc&~TPM_SC_PS_MASK)|tpmPrescale;
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param[in]  enable        True => enable, False => disable
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void INLINE_RELEASE enableNvicInterrupts(bool enable=true, uint32_t nvicPriority=NvicPriority_Normal) {

      if (enable) {
         enableNvicInterrupt(Info::irqNums[0], nvicPriority);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }

   /**
    * Enable/disable Timer Overflow interrupts
    *
    * @param[in] enable true to enable, false to disable
    */
   static void INLINE_RELEASE enableTimerOverflowInterrupts(bool enable=true) {
      if (enable) {
         tmr().SC |= TPM_SC_TOIE_MASK;
      }
      else {
         tmr().SC &= ~TPM_SC_TOIE_MASK;
      }
   }

   /**
    * Set modulo of counter
    *
    * This value is write-buffered and updated by MOD synchronisation.
    *
    * @param[in] modulo Modulo value in ticks (<65535)
    *
    * @note This function will affect all channels of the timer.
    */
   static void INLINE_RELEASE setMod(uint16_t modulo) {
      tmr().MOD = modulo;
   }

   /**
    * Set period
    *
    * @param[in] period Period in ticks (<65535)
    *
    * @return E_NO_ERROR       Success
    * @return E_TOO_LARGE      Failed to find suitable pre-scaler values
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note This function will affect all channels of the timer.
    */
   static ErrorCode setPeriodInTicks(uint32_t period) {

      // Check if CPWMS is set (affects period)
      bool centreAlign = (tmr().SC&TPM_SC_CPWMS_MASK);

      if (centreAlign) {
         // Centre-aligned period is 2*MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation

         // Halve with rounding
         period = (period+1)/2;
#ifdef DEBUG_BUILD
         if (period > 0x7FFFUL) {
            // Attempt to set too long a period
            return setErrorCode(E_TOO_LARGE);
         }
#endif
      }
      else {
         // Left-aligned period is MOD+1 value
         period = period-1;
#ifdef DEBUG_BUILD
         if (period > 0xFFFF) {
            // Attempt to set too long a period
            return setErrorCode(E_TOO_LARGE);
         }
#endif
      }
      // Disable timer so register changes are immediate
      uint8_t sc = tmr().SC;
      // Wait for TMR disable
      while (tmr().SC) {
         tmr().SC = 0;
      }

      // Change modulo
      tmr().MOD = period;

      // Restart timer
      tmr().SC  = sc;

      // OK period
      return E_NO_ERROR;
   }

   /**
    * Set period
    *
    * @param[in] period Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL => failed to find suitable values
    * @return E_TOO_LARGE => failed to find suitable values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note This function will affect all channels of the timer.
    */
   static ErrorCode setPeriod(float period) {
      float inputClock = Info::getInputClockFrequency();
      int prescaleFactor=1;
      int prescalerValue=0;

      // Maximum period value in ticks
      uint32_t maxPeriodInTicks = 65536;

      // Check if CPWMS is set (affects period calculation)
      if (tmr().SC&TPM_SC_CPWMS_MASK) {
         // Centre-aligned period is ~double the MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation so
         // period in ticks is limited to 2*0x7FFF
         maxPeriodInTicks = 65534;
      }
      while (prescalerValue<=7) {
         float    clock = inputClock/prescaleFactor;
         uint32_t periodInTicks   = round(period*clock);
         if (periodInTicks < Info::minimumResolution) {
            // Too short a period for minimum resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (periodInTicks <= maxPeriodInTicks) {
            // Disable timer to change prescaler
            uint32_t sc = tmr().SC;
            // Wait for disable so immediate effect
            while (tmr().SC) {
               tmr().SC = 0;
            }
            tmr().SC     = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);
            setPeriodInTicks(periodInTicks);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set measurement period.
    * Input Capture and Output Compare will be able to operate over
    *  at least this period without overflow.
    *
    * @param[in] period Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL => failed to find suitable values
    * @return E_TOO_LARGE => failed to find suitable values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note Timer period is set to maximum.
    * @note This function will affect all channels of the timer.
    */
   static INLINE_RELEASE ErrorCode setMeasurementPeriod(float period) {
      // Try to set capture period
      ErrorCode rc = setPeriod(period);
      // Set actual period to maximum ticks in any case
      // This is the usual value for IC or OC set-up
      setPeriodInTicks(0x10000);
      return rc;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   static INLINE_RELEASE float getTickFrequencyAsFloat() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr().SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return ((float)Info::getInputClockFrequency())/prescaleFactor;
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static INLINE_RELEASE uint32_t getTickFrequencyAsInt() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr().SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return Info::getInputClockFrequency()/prescaleFactor;
   }

   /**
    * Set approximate frequency of timer tick
    *
    * @param[in] frequency Frequency as a float
    * @param[in] tolerance Tolerance in percent
    *
    * @return E_NO_ERROR       Success
    * @return E_ILLEGAL_PARAM  Failed to find suitable pre-scaler values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note This function will affect all channels of the timer.
    */
   static ErrorCode setTickFrequency(float frequency, float tolerance) {
      float inputClockFrequency = Info::getInputClockFrequency();

      int prescaleFactor=1;
      int prescalerValue=0;
      while (prescalerValue<=7) {
         float tickFrequency = inputClockFrequency/prescaleFactor;

         if ((100*std::abs((tickFrequency/frequency)-1)) < tolerance) {
            // Clear SC so immediate effect on prescale change
            uint32_t sc = tmr().SC&~TPM_SC_PS_MASK;
            // Wait for disable so immediate effect
			// This is necessary due to clock domain crossing
            while (tmr().SC) {
               tmr().SC = 0;
            }
            tmr().SC     = sc|TPM_SC_PS(prescalerValue);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the TPM minimum resolution
    */
   static uint32_t convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = ((uint64_t)time*tickRate)/1000000;
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] time Time in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMeasurementPeriod()). \n
    * @note Will set error code if calculated value is less the TPM minimum resolution
    */
   static uint32_t convertSecondsToTicks(float time) {

      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = time*tickRate;
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] tickInterval Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMicroseconds(int tickInterval) {

      // Calculate period
      uint64_t rv = ((uint64_t)tickInterval*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert ticks to time in seconds
    *
    * @param[in] tickInterval Time in ticks as float
    *
    * @return Time in seconds
    */
   static float INLINE_RELEASE convertTicksToSeconds(int tickInterval) {
      // Calculate period
      return tickInterval/getTickFrequencyAsFloat();
   }

   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   static INLINE_RELEASE uint16_t getTime() {
      return tmr().CNT;
   }
   
   /**
    * Get Timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   static INLINE_RELEASE unsigned getInterruptFlags() {
      return tmr().STATUS;
   }

   /**
    * Get and Clear Timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
    */
   static INLINE_RELEASE unsigned getAndClearInterruptFlags() {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = tmr().STATUS;
      tmr().STATUS = ~status;
      return status;
   }


   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event i.e. value from timer event register
    */
   static INLINE_RELEASE uint16_t getEventTime(int channel) {
      return tmr().CONTROLS[channel].CnV;
   }

   /**
    * Set Timer event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Absolute event time i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   static void INLINE_RELEASE setEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV = eventTime;
   }

   /**
    * Set Timer event time relative to current event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Event time relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    */
   static void INLINE_RELEASE setDeltaEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV += eventTime;
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Event time relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    */
   static void INLINE_RELEASE setRelativeEventTime(uint16_t eventTime, int channel) {
      tmr().CONTROLS[channel].CnV = tmr().CNT + eventTime;
   }

   /**
    * Set PWM duty cycle\n
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the TPM register synchronisation mechanism
    */
   static void setDutyCycle(float dutyCycle, int channel) {
      if (tmr().SC&TPM_SC_CPWMS_MASK) {
         tmr().CONTROLS[channel].CnV  = round((dutyCycle*tmr().MOD)/100.0f);
      }
      else {
         tmr().CONTROLS[channel].CnV  = round((dutyCycle*(tmr().MOD+1))/100.0f);
      }
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the TPM register synchronisation mechanism
    */
   static void setDutyCycle(int dutyCycle, int channel) {
      if (tmr().SC&TPM_SC_CPWMS_MASK) {
         tmr().CONTROLS[channel].CnV  = (dutyCycle*tmr().MOD)/100;
      }
      else {
         tmr().CONTROLS[channel].CnV  = (dutyCycle*(tmr().MOD+1))/100;
      }
   }

   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    */
   static ErrorCode setHighTime(uint32_t highTime, int channel) {

      if (tmr().SC&TPM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1)/2;
      }
#ifdef DEBUG_BUILD
      if (highTime > tmr().MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      tmr().CONTROLS[channel].CnV  = highTime;
      return E_NO_ERROR;
   }

   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    */
   static INLINE_RELEASE ErrorCode setHighTime(float highTime, int channel) {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }

};

template<class Info> TpmCallbackFunction         TpmBase_T<Info>::sToiCallback     = TpmBase_T<Info>::unhandledCallback;
template<class Info> TpmChannelCallbackFunction  TpmBase_T<Info>::sChannelCallback = TpmBase_T<Info>::unhandledCallback;

/**
 * Template class representing a timer channel
 *
 * Example
 * @code
 * // Instantiate the timer channel (for TPM0 channel 6)
 * using Tmr0_ch6 = USBDM::TpmChannel<TPM0Info, 6>;
 *
 * // Enable and initialise Base TPM with initial alignment
 * Tmr0_ch6::Tpm::enable();
 * Tmr0_ch6::Tpm::configure(TpmMode_LeftAlign);
 *
 * // Enable channel as PWM
 * Tmr0_ch6::enable(TpmChMode_PwmHighTruePulses);
 *
 * // Change period (in ticks)
 * Tmr0_ch6.setPeriod(500);
 *
 * // Change duty cycle (in percent)
 * Tmr0_ch6.setDutyCycle(45);
 * @endcode
 *
 * @tparam channel TPM timer channel
 */
template <class Info, int channel>
class TpmChannel_T : public TpmBase_T<Info>, public PcrTable_T<Info, channel>, CheckSignal<Info, channel> {

public:
   // Allow more convenient access to template super-classes
   using Pcr = PcrTable_T<Info, channel>;
   using Tpm = TpmBase_T<Info>;

   // Allow access to timer hardware instance
   using TpmBase_T<Info>::tmr;

private:
   /*
    * I could use 'using' to hide these functions but the Eclipse
    * indexer gets confused about visibility
    */
   // Hide these TPM methods as TPM channel methods are preferred
   static unsigned getAndClearInterruptFlags() {return 0;};
   static unsigned getInterruptFlags()         {return 0;};

   // Hide these PCR methods as they are similar to TPM methods
   static void setCallback(PinCallbackFunction) {} // Use setPinCallback()
   static void setIrq(PinIrq) {}                   // Use setPinIrq()

public:
   /**
    * Set callback for Pin IRQ
    *
    * @param[in] callback The function to call on Pin interrupt.\n
    *                     nullptr to indicate none
    *
    * @note There is a single callback function for all pins on the related port.
    */
   static void INLINE_RELEASE setPinCallback(PinCallbackFunction callback) {
      Pcr::setCallback(callback);
   }

   /**
    * Clear interrupt flag on pin associated with channel
    * Assumes clock to the port has already been enabled
    */
   static void INLINE_RELEASE clearPinInterruptFlag() {
      Pcr::clearInterruptFlag();
   }
   /**
    * Sets interrupt/DMA mode on pin associated with channel
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinIrq Interrupt/DMA mode
    */
   static void INLINE_RELEASE setPinIrq(PinIrq pinIrq) {
      Pcr::setIrq(pinIrq);
   }

   /** Timer channel number */
   static constexpr uint32_t CHANNEL      = channel;

   /** Mask for Timer channel */
   static constexpr uint32_t CHANNEL_MASK = 1<<channel;

   /**
    * Configure channel and sets mode\n
    * Configures owning TPM with default settings from Configure.usbdmProject if not already enabled.
    *
    * @param[in] tpmChMode         Mode of operation for TPM e.g.TpmChMode_PwmHighTruePulses
    * @param[in] tpmChannelAction  Whether to enable the interrupt or DMA function on this channel
    *
    * @note Enables TPM as well
    * @note This method has the side-effect of clearing the register update synchronisation i.e. 
    *       pending CnV register updates are discarded.
    */
   static void defaultConfigure(
         TpmChMode         tpmChMode        = TpmChMode_PwmHighTruePulses,
         TpmChannelAction  tpmChannelAction = TpmChannelAction_None) {

      if (!Tpm::isEnabled()) {
         // Enable parent TPM if needed
         Tpm::configure();
      }
      tmr().CONTROLS[channel].CnSC = tpmChMode|TpmChannelAction_None;
   }

   /**
    * Configure channel\n
    * Doesn't affect shared settings of owning Timer
    *
    * @param[in] tpmChMode         Mode of operation for channel
    * @param[in] tpmChannelAction  Whether to enable the interrupt or DMA function on this channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   static void INLINE_RELEASE configure(
         TpmChMode         tpmChMode,
         TpmChannelAction  tpmChannelAction = TpmChannelAction_None) {

      // Check that owning TPM has been enabled
      usbdm_assert(Tpm::isEnabled(), "TPM is not enabled");
      
      tmr().CONTROLS[channel].CnSC = tpmChMode|tpmChannelAction;

      if (!Info::mapPinsOnEnable) {
         // Configure pin if used
         switch (tpmChMode) {
            case TpmChMode_Disabled :
            case TpmChMode_OutputCompare :
               // Don't change pin setting
               break;
            default:
               // Map pin to TPM
               Pcr::setPCR(Info::info[channel].pcrValue);
         }
      }
   }

   /**
    * Get channel mode
    *
    * @return Current mode of operation for the channel
    */
   static INLINE_RELEASE TpmChMode getMode() {
      return (TpmChMode)(tmr().CONTROLS[channel].CnSC &
            (TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK));
   }

   /**
    * Set channel mode
    *
    * @param[in] tpmChMode      Mode of operation for channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   static void INLINE_RELEASE setMode(TpmChMode tpmChMode) {
      tmr().CONTROLS[channel].CnSC =
            (tmr().CONTROLS[channel].CnSC & ~(TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK))|tpmChMode;
   }

   /**
    * Set channel action on event
    *
    * @param[in] tpmChannelAction  Whether to enable the interrupt or DMA function on this channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   static void INLINE_RELEASE setAction(TpmChannelAction tpmChannelAction) {
#ifdef TPM_CnSC_DMA
      tmr().CONTROLS[channel].CnSC =
            (tmr().CONTROLS[channel].CnSC & ~(TPM_CnSC_CHIE_MASK|TPM_CnSC_DMA_MASK))|tpmChannelAction;
#else
      tmr().CONTROLS[channel].CnSC =
            (tmr().CONTROLS[channel].CnSC & ~TPM_CnSC_CHIE_MASK)|tpmChannelAction;
#endif
   }

   /**
    * Enable or disable interrupt from this channel\n
    * Note: It is necessary to enableNvicInterrupts() as well
    *
    * @param[in] enable  True => enable, False => disable
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.\n
    *       pending CnV register updates are discarded.
    */
   static void INLINE_RELEASE enableInterrupts(bool enable=true) {
      if (enable) {
         tmr().CONTROLS[channel].CnSC |= TPM_CnSC_CHIE_MASK;
      }
      else {
         tmr().CONTROLS[channel].CnSC &= ~TPM_CnSC_CHIE_MASK;
      }
   }

#ifdef TPM_CnSC_DMA
   /**
    * Enable or disable DMA requests from this channel\n
    *
    * @param[in] enable  True => enable, False => disable
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.\n
    *       pending CnV register updates are discarded.
    */
   static void INLINE_RELEASE enableDma(bool enable=true) {
      if (enable) {
         tmr().CONTROLS[channel].CnSC |= TPM_CnSC_DMA_MASK;
      }
      else {
         tmr().CONTROLS[channel].CnSC &= ~TPM_CnSC_DMA_MASK;
      }
   }
#endif

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param[in] enable true to enable, false to disable
    */
   static void INLINE_RELEASE enableNvicInterrupts(bool enable=true) {
      TpmBase_T<Info>::enableNvicInterrupts(enable);
   }

   /**
    * Enable/disable Pin interrupts in NVIC
    *
    * @param[in] enable true => enable, false => disable
    */
   static void INLINE_RELEASE enablePinNvicInterrupts(bool enable=true) {
      Pcr::enableNvicInterrupts(enable);
   }

   /**
    * Set Pin Control Register Value. \n
    * Pin multiplexor value is forced to TPM channel function. \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pcrValue PCR value to set
    */
   static void INLINE_RELEASE setPCR(PcrValue pcrValue=Info::info[channel].pcrValue) {
      Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Set Pin Control Register (PCR) value \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinIrq           One of PinIrq_None, etc (defaults to PinIrq_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    * @param[in] pinMux           One of PinMux_Analogue, PinMux_Gpio etc (defaults to TPM selection value)
    */
   static void INLINE_RELEASE setPCR(
         PinPull           pinPull,
         PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinIrq            pinIrq            = PinIrq_None,
         PinFilter         pinFilter         = PinFilter_None,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast,
         PinMux            pinMux            = (PinMux)(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK)
         ) {
      Pcr::setPCR(pinPull,pinDriveStrength,pinDriveMode,pinIrq,pinFilter,pinSlewRate,pinMux);
   }

   /**
    * Configures Pin Control Register (PCR) value for a TPM input to default values\n
    * This will map the pin to the TPM function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @note Resets the Pin Control Register value (PCR value).
    */
   static void setOutput() {
      Pcr::setPCR(Info::info[channel].pcrValue);
   }

   /**
    * Set Pin Control Register (PCR) value \n
    * This will map the pin to the TPM function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
         ) {
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Configures Pin Control Register (PCR) value for a TPM input to default values\n
    * This will map the pin to the TPM function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @note Resets the Pin Control Register value (PCR value).
    */
   static void setInput() {
      Pcr::setPCR(Info::info[channel].pcrValue);
   }

   /**
    * Set Pin Control Register (PCR) value \n
    * This will map the pin to the TPM function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinIrq           One of PinIrq_None, etc (defaults to PinIrq_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull,
         PinIrq            pinIrq            = PinIrq_None,
         PinFilter         pinFilter         = PinFilter_None
         ) {
      Pcr::setPCR(pinPull|pinIrq|pinFilter|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Set PWM high time in ticks\n
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static INLINE_RELEASE ErrorCode setHighTimeInTicks(uint32_t highTime) {
      return Tpm::setHighTime(highTime, channel);
   }

   /**
    * Set PWM high time in seconds\n
    * Higher precision float version
    *
    * @param[in] highTime   PWM high time in seconds
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static INLINE_RELEASE ErrorCode setHighTime(float highTime) {
      return Tpm::setHighTime(highTime, channel);
   }
   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static void INLINE_RELEASE setDutyCycle(int dutyCycle) {
      Tpm::setDutyCycle(dutyCycle, channel);
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static void INLINE_RELEASE setDutyCycle(float dutyCycle) {
      Tpm::setDutyCycle(dutyCycle, channel);
   }

   /**
    * Set Timer event time
    *
    * @param[in] offset  Event time relative to current event time (i.e. Timer channel CnV value)
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static void INLINE_RELEASE setDeltaEventTime(uint16_t offset) {
      Tpm::setDeltaEventTime(offset, channel);
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] offset  Event time relative to current time (i.e. Timer CNT value)
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static void INLINE_RELEASE setRelativeEventTime(uint16_t offset) {
      Tpm::setRelativeEventTime(offset, channel);
   }

   /**
    * Set Absolute Timer event time
    *
    * @param[in] eventTime  Absolute event time i.e. value to use as timer comparison value
    *
    * @note The actual CnV register update will be delayed by the TPM register synchronisation mechanism
    */
   static void INLINE_RELEASE setEventTime(uint16_t eventTime) {
      Tpm::setEventTime(eventTime, channel);
   }

   /**
    * Get Absolute Timer event time
    *
    * @return Absolute time of last event i.e. value from timer event register
    */
   static INLINE_RELEASE uint16_t getEventTime() {
      return Tpm::getEventTime(channel);
   }

   /**
    * Get Timer interrupt flag
    *
    * @return true  Indicates an event has occurred on a channel
    * @return false Indicates no event has occurred on a channel since last polled
    */
   static INLINE_RELEASE bool getInterruptFlag() {
      return (tmr().STATUS&CHANNEL_MASK) != 0;
   }

   /**
    * Get and Clear Timer interrupt flag
    *
    * @return true  Indicates an event has occurred on a channel
    * @return false Indicates no event has occurred on a channel since last polled
    *
    * @note Only flags captured in the return value are cleared
    */
   static INLINE_RELEASE bool getAndClearInterruptFlag() {
      // Note - requires read and write zero to clear flags
      // so only flags captured in status are cleared
      bool status = (tmr().STATUS&CHANNEL_MASK) != 0;
      tmr().STATUS = ~CHANNEL_MASK;
      return status;
   }

   /**
    * Clear interrupt flag on channel
    */
   static void INLINE_RELEASE clearInterruptFlag() {
      // Note - requires one to clear flag
      tmr().CONTROLS[channel].CnSC = TPM_CnSC_CHF_MASK;
   }
};

#ifdef USBDM_TPM0_IS_DEFINED
/**
 * Template class representing a Timer channel
 *
 * Example
 * @code
 * // Instantiate the timer channel (for TPM0 channel 6)
 * using Tmr0_ch6 = USBDM::Tpm0Channel<6>;
 *
 * // Enable and initialise Base TPM with initial alignment
 * Tmr0_ch6::Tpm::configure(TpmMode_LeftAlign);
 *
 * // Change timer period (in ticks) (affects ALL channels of timer)
 * Tmr0_ch6.Tpm::setPeriod(500);
 *
 * // Configure channel as PWM
 * Tmr0_ch6::configure(TpmChMode_PwmHighTruePulses);
 *
 * // Change duty cycle (in percent)
 * Tmr0_ch6.setDutyCycle(45);
 * @endcode
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Tpm0Channel : public TpmChannel_T<Tpm0Info, channel> {};

/**
 * Class representing TPM0
 */
using Tpm0 = TpmBase_T<Tpm0Info>;
#endif

#ifdef USBDM_TPM1_IS_DEFINED
/**
 * Template class representing a TPM1 timer channel
 *
 * Refer @ref Tpm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Tpm1Channel : public TpmChannel_T<Tpm1Info, channel> {};

/**
 * Class representing TPM1
 */
using Tpm1 = TpmBase_T<Tpm1Info>;
#endif

#ifdef USBDM_TPM2_IS_DEFINED
/**
 * Template class representing a TPM2 timer channel
 *
 * Refer @ref Tpm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Tpm2Channel : public TpmChannel_T<Tpm2Info, channel> {};

/**
 * Class representing TPM2
 */
using Tpm2 = TpmBase_T<Tpm2Info>;
#endif

#ifdef USBDM_TPM3_IS_DEFINED
/**
 * Template class representing a TPM3 timer channel
 *
 * Refer @ref Tpm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Tpm3Channel : public TpmBase_T<Tpm3Info>, CheckSignal<Tpm2Info, channel> {

/**
 * Class representing TPM3
 */
   using Tpm3 = TpmBase_T<Tpm3Info>;
#endif

#if defined(TPM_QDCTRL_QUADEN_MASK)
/**
 * Template class representing a TPM configured as a Quadrature encoder
 *
 * @tparam info      Information class for TPM
 *
 * @code
 *  using QuadDecoder = QuadDecoderTpm_T<Tpm0Info>;
 *
 *  // Enable decoder
 *  QuadDecoder::configure();
 *
 *  // Set pin filters
 *  QuadDecoder::enableFilter(15);
 *
 *  // Reset position to zero
 *  // Movement will be +/- relative to this initial position
 *  QuadDecoder::resetPosition();
 *
 *  for(;;) {
 *     console.write("Position =").writeln(QuadDecoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class QuadDecoderTpm_T : public TpmBase_T<Info> {

#ifdef DEBUG_BUILD
   static_assert(Info::InfoQUAD::info[0].gpioBit != UNMAPPED_PCR, "QuadDecoder_T: TPM PHA is not mapped to a pin - Modify Configure.usbdm");
   static_assert(Info::InfoQUAD::info[1].gpioBit != UNMAPPED_PCR, "QuadDecoder_T: TPM PHB is not mapped to a pin - Modify Configure.usbdm");
#endif

public:

   using TpmBase_T<Info>::setTimerOverflowCallback;
   using TpmBase_T<Info>::enableTimerOverflowInterrupts;
   using TpmBase_T<Info>::enableNvicInterrupts;

   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile TPM_Type &tpm() { return Info::tpm(); }

   /** Clock register for peripheral */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    *
    * @param prescaler Prescale value applied to the output of the quadrature decode before the counter.
    */
   static void configure(TpmPrescale prescaler = TpmPrescale_1) {
      Info::InfoQUAD::initPCRs();

      // Enable clock to timer
      clockReg() |= Info::clockMask;
      __DMB();

      TpmBase_T<Info>::configure(TpmMode_Quadrature, TpmClockSource_Disabled, prescaler);

      tpm().QDCTRL =
            TPM_QDCTRL_QUADEN_MASK|      // Enable Quadrature decoder
            TPM_QDCTRL_QUADMODE(0);      // Quadrature mode
      tpm().CONF   = TPM_CONF_DBGMODE(3);
   }

   /**
    * Reset position to zero
    */
   static void INLINE_RELEASE resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      tpm().CNT = 0;
   }
   /**
    * Get Quadrature decoder position
    *
    * @return Signed number representing position relative to reference location
    */
   static INLINE_RELEASE int16_t getPosition() {
      return (int16_t)(tpm().CNT);
   }
};

#ifdef USBDM_TPM1_IS_DEFINED
/**
 * Class representing TPM1 as Quadrature decoder
 * Not all TPMs support this mode
 */
using TpmQuadDecoder1 = QuadDecoderTpm_T<Tpm1Info>;
#endif

#ifdef USBDM_TPM2_IS_DEFINED
/**
 * Class representing TPM2 as Quadrature decoder
 * Not all TPMs support this mode
 */
using TpmQuadDecoder2 = QuadDecoderTpm_T<Tpm2Info>;
#endif

#endif // USBDM_TPM3_IS_DEFINED

/**
 * End TPM_Group
 * @}
 */
 
} // End namespace USBDM

#endif /* HEADER_TPM_H */

