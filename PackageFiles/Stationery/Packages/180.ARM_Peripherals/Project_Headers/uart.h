/****************************************************************************************************//**
 * @file     uart.h (180.ARM_Peripherals/Project_Headers/uart.h)
 * @brief    Universal Asynchronous Receiver/Transmitter interface
 *
 * @version  V0.0
 * @date     2015/06
 *
 *******************************************************************************************************/

#ifndef INCLUDE_USBDM_UART_H_
#define INCLUDE_USBDM_UART_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include <cstdio>
#include "derivative.h"
#include "hardware.h"
#include "mcg.h"

namespace USBDM {

/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief C++ Class allowing access to UART interface
 * @{
 */

/**
 * Enumeration selecting interrupt sources
 */
enum UartInterrupt {
   UartInterrupt_TxHoldingEmpty  = UART_C2_TIE(1),   //!< Interrupt request on Transmit holding register empty
   UartInterrupt_TxComplete      = UART_C2_TCIE(1),  //!< Interrupt request on Transmit complete
   UartInterrupt_RxFull          = UART_C2_RIE(1),   //!< Interrupt request on Receive holding full
   UartInterrupt_IdleDetect      = UART_C2_ILIE(1),  //!< Interrupt request on Idle detection
};

enum Radix {
   Radix_2  = 2,
   Radix_8  = 8,
   Radix_10 = 10,
   Radix_16 = 16,
};

/**
 * Enumeration selecting direct memory access sources
 */
enum UartDma {
#ifdef UART_C5_TDMAS
   UartDma_TxHoldingEmpty  = UART_C5_TDMAS(1),   //!< DMA request on Transmit holding register empty
   UartDma_RxFull          = UART_C5_RDMAS(1),   //!< DMA request on Receive holding full
#endif
#ifdef UART_C5_TDMAE
   UartDma_TxHoldingEmpty  = UART_C5_TDMAE(1),   //!< DMA request on Transmit holding register empty
   UartDma_RxFull          = UART_C5_RDMAE(1),   //!< DMA request on Receive holding full
#endif
};

/**
 * Virtual Base class for UART interface
 */
class Uart {

public:

   volatile UART_Type * const uart;            //!< UART hardware instance

protected:

   virtual ~Uart() {}

   /**
    * Construct UART interface
    *
    * @param[in]  uart             Base address of UART hardware
    */
   Uart(volatile UART_Type *uart) : uart(uart) {
   }

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and UART clock frequency
    *
    * @param[in]  baudrate       - Interface speed in bits-per-second
    * @param[in]  clockFrequency - Frequency of UART clock
    */
   void __attribute__((noinline)) setBaudRate(uint32_t baudrate, uint32_t clockFrequency) {

      // Disable UART before changing registers
      uart->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);

      // Calculate UART clock setting (5-bit fraction at right)
      int scaledBaudValue = (2*clockFrequency)/baudrate;

#ifdef UART_C4_BRFA_MASK
      // Set Baud rate register
      uart->BDH = (uart->BDH&~UART_BDH_SBR_MASK) | UART_BDH_SBR((scaledBaudValue>>(8+5)));
      uart->BDL = UART_BDL_SBR(scaledBaudValue>>5);
      // Fractional divider to get closer to the baud rate
      uart->C4 = (uart->C4&~UART_C4_BRFA_MASK) | UART_C4_BRFA(scaledBaudValue);
#else
      scaledBaudValue += 1<<4; // Round value
      // Set Baud rate register
      uart->BDH = (uart->BDH&~UART_BDH_SBR_MASK) | UART_BDH_SBR((scaledBaudValue>>(8+5)));
      uart->BDL = UART_BDL_SBR(scaledBaudValue>>5);
#endif

      uart->C1 = 0;

#if USE_IRQ
      // Enable UART Tx & Rx - with Rx IRQ
      uart->C2 = UART_C2_TE_MASK|UART_C2_RE_MASK|UART_C2_RIE_MASK;
#else
      // Enable UART Tx & Rx
      uart->C2 = UART_C2_TE_MASK|UART_C2_RE_MASK;
#endif
   }

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and LPUART clock frequency
    *
    * @param[in]  baudrate       - Interface speed in bits-per-second
    */
   virtual void setBaudRate(unsigned baudrate) = 0;

   /**
    * Current radix for << operator
    */
   Radix fRadix = Radix_10;

public:
   /**
    * Converts an unsigned long to a string
    *
    * @param[in] value Unsigned long to convert
    * @param[in] ptr   Buffer to write result (at least 12 characters)
    * @param[in] radix Radix for conversion [2..16]
    *
    * @return Pointer to '\0' null character at end of converted number\n
    *         May be used for incrementally writing to a buffer.
    */
   static __attribute__((noinline)) char *ultoa(unsigned long value, char *ptr, int radix=10) {
#ifdef DEBUG_BUILD
      if (ptr == nullptr) {
         __BKPT();
      }
      if ((radix<2)||(radix>16)) {
         __BKPT();
      }
#endif
      // Save beginning for reversal
      char *beginPtr = ptr;
      // Convert backwards
      do {
         *ptr++ = "0123456789ABCDEF"[value % radix];
         value /= radix;
      } while (value != 0);
      // Terminate and leave ptr at last digit
      *ptr = '\0';
      // Reverse digits
      char *endPtr = ptr-1;
      while (beginPtr < endPtr) {
         char t = *beginPtr;
         *beginPtr++ = *endPtr;
         *endPtr-- = t;
      }
      return ptr;
   }

   /**
    * Converts a long to a string
    *
    * @param[in] value Long to convert
    * @param[in] ptr   Buffer to write result (at least 12 characters)
    * @param[in] radix Radix for conversion [2..16]
    *
    * @return Pointer to '\0' null character at end of converted number\n
    *         May be used for incrementally writing to a buffer.
    */
   static char *ltoa(long value, char *ptr, int radix=10) {
      if (value<0) {
         *ptr++ = '-';
         value = -value;
      }
      return ultoa(value, ptr, radix);
   }

   /**
    * Copies a C string including terminating '\0' character
    *
    * @param[out] dst  Where to copy string
    * @param[in]  src  Source to copy from
    *
    * @return Pointer to '\0' null character at end of converted number\n
    *         May be used for incrementally writing to a buffer.
    */
   static __attribute__((noinline)) char *strcpy(char *dst, const char *src) {
#ifdef DEBUG_BUILD
      if (dst == nullptr) {
         __BKPT();
      }
#endif
      do {
         *dst++ = *src;
      } while (*src++ != '\0');
      return dst-1;
   }

   /**
    * Transmit message
    *
    * @param[in]  data     Data to transmit
    * @param[in]  size     Size of transmission data
    */
   void transmit(const uint8_t data[], uint16_t size) {
      while (size-->0) {
         write(*data++);
      }
   }

   /**
    * Receive message
    *
    * @param[out] data     Data buffer for reception
    * @param[in]  size     Size of data to receive
    */
   void receive(uint8_t data[], uint16_t size) {
      while (size-->0) {
         *data++ = readChar();
      }
   }
   /**
    * Check if character is available from UART
    *
    * @return true  Character available i.e. readChar() will not block
    * @return false No character available
    */
   bool isCharAvailable() {
      return (uart->S1 & UART_S1_RDRF_MASK) != 0;
   }

   /**
    * Receives a single character over the UART (blocking)
    *
    * @return Character received
    */
   int __attribute__((noinline)) readChar(void) {
      uint8_t status;
      // Wait for Rx buffer full
      do {
         status = uart->S1;
         // Clear & ignore pending errors
         if ((status & (UART_S1_FE_MASK|UART_S1_OR_MASK|UART_S1_PF_MASK|UART_S1_NF_MASK)) != 0) {
            clearError();
         }
      }  while ((status & UART_S1_RDRF_MASK) == 0);
      int ch = uart->D;
      if (ch == '\r') {
         ch = '\n';
      }
      return ch;
   }
   /**
    * Transmit a character
    *
    * @param[in]  ch - character to send
    */
   Uart __attribute__((noinline)) &write(char ch) {
      while ((uart->S1 & UART_S1_TDRE_MASK) == 0) {
         // Wait for Tx buffer empty
         __asm__("nop");
      }
      uart->D = ch;
      if (ch=='\n') {
         write('\r');
      }
      return *this;
   }
   /**
    * Transmit a character with newline
    *
    * @param[in]  ch - character to send
    */
   Uart &writeln(char ch) {
      write(ch);
      return write('\n');
   }
   /**
    * Transmit a C string
    *
    * @param[in]  str String to print
    */
   Uart &write(const char *str) {
      while (*str != '\0') {
         write(*str++);
      }
      return *this;
   }
   /**
    * Transmit a C string with new line
    *
    * @param[in]  str String to print
    */
   Uart INLINE_RELEASE &writeln(const char *str) {
      write(str);
      return write('\n');
   }
   /**
    * Transmit an unsigned long integer
    *
    * @param[in]  value Unsigned long to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart __attribute__((noinline)) &write(unsigned long value, int radix=10) {
      static char buff[35];
      ultoa(value, buff, radix);
      return write(buff);
   }
   /**
    * Transmit an unsigned long integer with newline
    *
    * @param[in]  value Unsigned long to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &writeln(unsigned long value, int radix=10) {
      write(value, radix);
      return write('\n');
   }
   /**
    * Transmit a long integer
    *
    * @param[in]  value Long to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &write(long value, int radix=10) {
      if (value<0) {
         write('-');
         value = -value;
      }
      return write((unsigned long) value, radix);
   }
   /**
    * Transmit a long integer with newline
    *
    * @param[in]  value Long to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &writeln(long value, int radix=10) {
      write(value, radix);
      return write('\n');
   }

   /**
    * Transmit an unsigned integer
    *
    * @param[in]  value Unsigned to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &write(unsigned value, int radix=10) {
      return write((unsigned long)value, radix);
   }
   /**
    * Transmit an unsigned integer with newline
    *
    * @param[in]  value Unsigned to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &writeln(unsigned value, int radix=10) {
      return writeln((unsigned long)value, radix);
   }
   /**
    * Transmit an integer
    *
    * @param[in]  value Integer to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE &write(int value, int radix=10) {
      return write((long)value, radix);
   }
   /**
    * Transmit an integer with newline
    *
    * @param[in]  value Integer to print
    * @param[in]  radix Radix for conversion [2..16]
    */
   Uart INLINE_RELEASE  &writeln(int value, int radix=10) {
      return writeln((long)value, radix);
   }
   /**
    * Transmit a double
    *
    * @param[in]  value Double to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float)).
    */
   Uart &write(double value) {
      char buff[20];
      snprintf(buff, sizeof(buff), "%f", value);
      return write(buff);
   }
   /**
    * Transmit a double with newline
    *
    * @param[in]  value Double to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float).
    */
   Uart INLINE_RELEASE &writeln(double value) {
      write(value);
      return write('\n');
   }
   /**
    * Transmit a float
    *
    * @param[in]  value Float to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float).
    */
   Uart INLINE_RELEASE &write(float value) {
      return write((double)value);
   }
   /**
    * Transmit a float with newline
    *
    * @param[in]  value Float to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float)).
    */
   Uart INLINE_RELEASE &writeln(float value) {
      return writeln((double)value);
   }
   /**
    * Transmit a character
    *
    * @param[in]  ch - character to send
    *
    * @return Reference to the Uart
     */
   Uart INLINE_RELEASE &operator <<(const char ch) {
      return write(ch);
   }
   /**
    * Transmit a C string
    *
    * @param[in]  str String to print
    *
    * @return Reference to the Uart
    */
   Uart INLINE_RELEASE &operator <<(const char *str) {
      return write(str);
   }
   /**
    * Transmit an unsigned long integer
    *
    * @param[in]  value Unsigned long to print
    *
    * @return Reference to the Uart
    */
   Uart INLINE_RELEASE &operator <<(unsigned long value) {
      return write(value, fRadix);
   }
   /**
    * Transmit a long integer
    *
    * @param[in]  value Long to print
    *
    * @return Reference to the Uart
    */
   Uart INLINE_RELEASE &operator <<(long value) {
      return write(value, fRadix);
   }
   /**
    * Transmit an unsigned integer
    *
    * @param[in]  value Unsigned to print
    *
    * @return Reference to the Uart
    */
   Uart INLINE_RELEASE &operator <<(unsigned int value) {
      return write(value, fRadix);
   }
   /**
    * Transmit an integer
    *
    * @param[in]  value Integer to print
    *
    * @return Reference to the Uart
    */
   Uart INLINE_RELEASE &operator <<(int value) {
      return write(value, fRadix);
   }
   /**
    * Transmit a float
    *
    * @param[in]  value Float to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float)).
    */
   Uart INLINE_RELEASE &operator <<(float value) {
      return write((double)value);
   }
   /**
    * Transmit a double
    *
    * @param[in]  value Double to print
    *
    * @note Uses snprintf() which is large.
    * @note To use this function it is necessary to enable floating point printing\n
    *       in the linker options (Support %f format in printf -u _print_float)).
    */
   Uart INLINE_RELEASE &operator <<(double value) {
      return write(value);
   }

   /**
    * Sets the conversion radix for integer types
    *
    * @param radix Radix to set
    *
    * @return Reference to the Uart
    *
    * @note Only applies for operator<< methods
    */
   Uart INLINE_RELEASE &operator <<(Radix radix) {
      fRadix = radix;
      return *this;
   }

   /**
    * Get conversion radix for given base
    *
    * @param radix Base to convert to radix [2..16]
    *
    * @return Radix corresponding to base
    */
   static Radix radix(int radix) {
      return (Radix)radix;
   }

   /**
    * Clear UART error status
    */
   virtual void clearError() = 0;

   /**
    * Enable/disable an interrupt source
    *
    * @param[in] uartInterrupt Interrupt source to modify
    * @param[in] enable        True to enable, false to disable
    *
    * @note Changing the enabled interrupt functions may also affect the DMA settings
    */
   void enableInterrupt(UartInterrupt uartInterrupt, bool enable=true) {
      if (enable) {
#ifdef UART_C5_TDMAS
         uart->C5 &= ~uartInterrupt; // DMA must be off to enable interrupts
#endif
         uart->C2 |= uartInterrupt;
      }
      else {
         uart->C2 &= ~uartInterrupt; // May also disable DMA
      }
   }
   /**
    * Enable/disable a DMA source
    *
    * @param[in] uartDma  Interrupt source to modify
    * @param[in] enable   True to enable, false to disable
    *
    * @note Changing the enabled DMA functions may also affect the interrupt settings
    */
   void enableDma(UartDma uartDma, bool enable=true) {
      // Flags are in same positions in the C3 and C5
      if (enable) {
         uart->C5 |= uartDma;
#ifdef UART_C5_TDMAS
         uart->C2 |= uartDma; // Interrupts must be enable for DMA
#endif
      }
      else {
#ifdef UART_C5_TDMAS
         uart->C2 &= ~uartDma; // Switching DMA off shouldn't enable interrupts!
#endif
         uart->C5 &= ~uartDma;
      }
   }
};

/**
 * @brief Template class representing an UART interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart0 = new USBDM::Uart_T<Uart1Info>(DEFAULT_BAUD_RATE, SYSTEM_UART0_CLOCK);
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
template<class Info> class Uart_T : public Uart {
public:
   /**
    * Construct UART interface
    *
    * @param[in]  baudrate         Interface speed in bits-per-second
    */
   Uart_T(unsigned baudrate) : Uart(Info::uart) {
      // Enable clock to UART interface
      *Info::clockReg |= Info::clockMask;

      // Configure pins
      Info::initPCRs();
      setBaudRate(baudrate);
   }

   ~Uart_T() {}

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and LPUART clock frequency
    *
    * @param[in]  baudrate       - Interface speed in bits-per-second
    */
   void INLINE_RELEASE setBaudRate(unsigned baudrate) {
      Uart::setBaudRate(baudrate, Info::getInputClockFrequency());
   }

protected:
   /**
    * Clear UART error status
    */
   virtual void clearError() {
      if (Info::statusNeedsWrite) {
         uart->S1 = 0xFF;
      }
      else {
         (void)uart->D;
      }
   }
};

/**
 * Type definition for UART interrupt call back
 *
 *  @param[in]  status - Interrupt flags e.g. UART_S1_TDRE, UART_S1_RDRF etc
 */
typedef void (*UARTCallbackFunction)(uint8_t status);

/**
 * Template class to provide UART callback
 */
template<class Info>
class UartIrq_T : public Uart_T<Info> {

protected:
   /** Callback function for ISR */
   static UARTCallbackFunction rxTxCallback;
   static UARTCallbackFunction errorCallback;

   static void unexpectedInterrupt(uint8_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   UartIrq_T(unsigned baud) : Uart_T<Info>(baud) {
   }

public:
   /**
    * Receive/Transmit IRQ handler
    */
   static void irqRxTxHandler(void) {
      uint8_t status = Info::uart->S1;
      rxTxCallback(status);
   }

   /**
    * Error and LON event IRQ handler
    */
   static void irqErrorHandler(void) {
      uint8_t status = Info::uart->S1;
      errorCallback(status);
   }

   /**
    * Set Receive/Transmit Callback function
    *
    *   @param[in]  callback - Callback function to be executed on UART receive or transmit
    */
   static void setRxTxCallback(UARTCallbackFunction callback) {
      if (callback == nullptr) {
         rxTxCallback = unexpectedInterrupt;
      }
      rxTxCallback = callback;
   }
   /**
    * Set Error Callback function
    *
    *   @param[in]  callback - Callback function to be executed on UART receive or transmit
    */
   static void setErrorCallback(UARTCallbackFunction callback) {
      if (callback == nullptr) {
         errorCallback = unexpectedInterrupt;
      }
      errorCallback = callback;
   }
};

template<class Info> UARTCallbackFunction UartIrq_T<Info>::rxTxCallback  = unexpectedInterrupt;
template<class Info> UARTCallbackFunction UartIrq_T<Info>::errorCallback = unexpectedInterrupt;

#ifdef USBDM_UART0_IS_DEFINED
/**
 * @brief Class representing UART0 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart = new USBDM::Uart1();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
class Uart0 : public UartIrq_T<Uart0Info> {
public:
   Uart0(unsigned baud=Uart0Info::defaultBaudRate) : UartIrq_T(baud) {
   }
};
#endif

#ifdef USBDM_UART1_IS_DEFINED
/**
 * @brief Class representing UART1 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart = new USBDM::Uart1();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
class Uart1 : public UartIrq_T<Uart1Info> {
public:
   /**
    * Construct UART interface
    *
    * @param[in]  baudrate         Interface speed in bits-per-second
    */
   Uart1(unsigned baudrate=Uart1Info::defaultBaudRate) : UartIrq_T(baudrate) {
   }
};
#endif

#ifdef USBDM_UART2_IS_DEFINED
/**
 * @brief Class representing UART2 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart = new USBDM::Uart2();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
class Uart2 : public UartIrq_T<Uart2Info> {
public:
   /**
    * Construct UART interface
    *
    * @param[in]  baudrate         Interface speed in bits-per-second
    */
   Uart2(unsigned baudrate=Uart2Info::defaultBaudRate) : UartIrq_T(baudrate) {
   }
};
#endif

#ifdef USBDM_UART3_IS_DEFINED
/**
 * @brief Class representing UART3 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart = new USBDM::Uart3();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
class Uart3 : public UartIrq_T<Uart3Info> {
public:
   /**
    * Construct UART interface
    *
    * @param[in]  baudrate         Interface speed in bits-per-second
    * @param[in]  clockFrequency   Frequency of UART clock (SystemCoreClock or SystemBusClock)
    */
   Uart3(unsigned baudrate=Uart3Info::defaultBaudRate) : UartIrq_T(baudrate) {
   }
};
#endif

#ifdef USBDM_UART4_IS_DEFINED
/**
 * @brief Class representing UART4 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Uart *uart = new USBDM::Uart4();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
class Uart4 : public UartIrq_T<Uart4Info> {
public:
   /**
    * Construct UART interface
    *
    * @param[in]  baudrate         Interface speed in bits-per-second
    * @param[in]  clockFrequency   Frequency of UART clock (SystemCoreClock or SystemBusClock)
    */
   Uart4(unsigned baudrate=Uart4Info::defaultBaudRate) : UartIrq_T(baudrate) {
   }
};
#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_UART_H_ */
