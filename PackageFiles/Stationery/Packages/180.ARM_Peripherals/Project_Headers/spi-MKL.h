/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MKL.h)
 * @brief    Serial Peripheral Interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "dma.h"
#include "hardware.h"
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

namespace USBDM {

extern "C" void SPI0_IRQHandler(void);
extern "C" void SPI1_IRQHandler(void);
extern "C" void SPI2_IRQHandler(void);

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */

enum SpiMode {
   SpiMode0 = SPI_C1_CPOL(0)|SPI_C1_CPHA(0), // Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode1 = SPI_C1_CPOL(0)|SPI_C1_CPHA(1), // Active-high clock (idles low), Data is changes on leading edge of SCK and captured on the following edge.
   SpiMode2 = SPI_C1_CPOL(1)|SPI_C1_CPHA(0), // Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode3 = SPI_C1_CPOL(1)|SPI_C1_CPHA(1), // Active-low clock (idles high), Data is changes on leading edge of SCK and captured on the following edge.
};

enum SpiOrder {
   SpiMsbFirst = SPI_C1_LSBFE(0),
   SpiLsbFirst = SPI_C1_LSBFE(1),
};

using SpiModeValue = uint32_t;

/**
 * Calculate SPI mode value from components
 *
 * @param spiMode  SPI Mode e.g. SpiMode0
 * @param spiOrder Bit order e.g. SpiMsbFirst
 */
static constexpr SpiModeValue spiModeValue(SpiMode spiMode=SpiMode0, SpiOrder spiOrder=SpiMsbFirst) {
   return spiMode|spiOrder;
}

/**
 * @brief Base class for representing an SPI interface
 */
class Spi {

protected:
   ~Spi() {}

   /**
    * Note on MODFEN/SSOE use
    *  SSOE  MODFEN     MASTER      SLAVE
    *   0     0         GPIO        SS-in
    *   0     1         FAULT       SS-in
    *   1     0         GPIO        SS-in
    *   1     1         SS-out      SS-in
    */
protected:
   volatile  SPI_Type  *const spi;           //!< SPI hardware
   DmaChannel          *dmacTxChannel;       //!< DMA hardware
   DmaChannel          *dmacRxChannel;       //!< DMA hardware
   uint8_t              dmaSpiRxSlot;        //!< DMA slot (1st of Tx/Rx pair)
   uint32_t             interfaceFrequency;  //!< Interface frequency to use
   uint8_t              spiC1BaseValue;      //!< Base value for spi->C1

protected:
   /**
    * Constructor
    *
    * @param baseAddress    Base address of SPI
    * @param dmaTxChannel   DMA Channel for transmission
    * @param dmaRxChannel   DMA Channel for reception
    * @param rxMuxSource    Receive Mux value
    */
   Spi(volatile SPI_Type *baseAddress, DmaChannel *dmaTxChannel, DmaChannel *dmaRxChannel, uint8_t rxMuxSource) :
      spi(baseAddress),
      dmacTxChannel(dmaTxChannel),
      dmacRxChannel(dmaRxChannel),
      dmaSpiRxSlot(rxMuxSource),
      interfaceFrequency(Spi0Info::speed) {

      spiC1BaseValue = SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK;
   }

public:
   /**
    * Enable pins used by SPI
    */
   virtual void enablePins() = 0;

   /**
    * Disable (restore to usual default) pins used by SPI
    */
   virtual void disablePins() = 0;

   /**
    * Sets Communication speed for SPI
    *
    * @param frequency => Frequency in Hz (0 => use default value)
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(uint32_t frequency);

   /**
    * Sets Communication mode for SPI
    *
    * @param mode => Mode to set. Combination of SPI_CPHA, SPI_CPOL and SPI_LSBFE
    */
   void setMode(uint32_t mode) {
      // Note: always master mode
      spi->C1 = (mode & (SPI_C1_CPHA_MASK|SPI_C1_CPOL_MASK|SPI_C1_LSBFE_MASK))|SPI_C1_SSOE_MASK|SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK;
   }
   /**
    * Gets current speed of interface
    *
    * @return Speed in Hz
    */
   uint32_t getSpeed(void) {
      return interfaceFrequency;
   }
   /**
    *  Transmit and receive a series of bytes
    *
    *  @param dataSize  Number of bytes to transfer
    *  @param txData   Transmit bytes (may be NULL for Rx only)
    *  @param rxData    Receive byte buffer (may be NULL for Tx only)
    *
    *  Note: rxData may use same buffer as txData
    */
   virtual void txRxBytes(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=0);
   /**
    * Transmit and receive an 8-bit value over SPI
    *
    * @param data - Data to send
    *
    * @return Data received
    */
   virtual uint32_t txRx(uint32_t data);
};

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  spiBasePtr     Base address of SPI hardware
 * @tparam  spiClockReg    Address of SIM register controlling SPI hardware clock
 * @tparam  spiClockMask   Clock mask for SIM clock register
 * @tparam  SpiSCK         Pcr used for SCK signal
 * @tparam  SpiMISO        Pcr used for MISO signal
 * @tparam  SpiMOSI        Pcr used for MOSI signal
 * @tparam  Rest...        Pcr used for PCSx (These are initialised but not used)
 */
template<class Info, typename ... Rest>
class Spi_T : public Spi {

protected:
   static constexpr volatile SPI_Type *spi      = Info::spi;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

private:
   using SpiSCK   = PcrTable_T<Info, 0>;
   using SpiMISO  = PcrTable_T<Info, 1>;
   using SpiMOSI  = PcrTable_T<Info, 2>;

public:
   virtual void enablePins() {
      // Configure SPI pins
      processPcrs<SpiSCK, SpiMISO, SpiMOSI, Rest...>();
   }

   virtual void disablePins() {
      // Configure SPI pins
      processPcrs<SpiSCK, SpiMISO, SpiMOSI, Rest...>(0);
   }

protected:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    * @param rxMuxSource  Receive Mux value (Tx mux value is assumed to be rxMuxSource+1)
    */
   Spi_T(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel, uint8_t rxMuxSource) :
      Spi(spi, dmaTxChannel, dmaRxChannel, rxMuxSource) {

      // Enable SPI module clock
      *clockReg |= Info::clockMask;

      // Configure SPI pins
      enablePins();

      // Use default speed
      setSpeed();
   }
};

#if defined(USBDM_SPI0_IS_DEFINED) && (SPI0_SCK_PIN_SEL!=0) && (SPI0_MOSI_PIN_SEL!=0) && (SPI0_MISO_PIN_SEL!=0)
#if (SPI0_PCS0_PIN_SEL!=0)
/**
 * @brief Class representing SPI0 interface with hardware PCS
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi0pcs(new USBDM::DmaChannel0(), new USBDM::DmaChannel1(), USBDM::DMA_SLOT_SPI0_Receive);
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 */
class Spi0 : public Spi_T<Spi0Info, Spi1_PCS0> {

public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    * @param rxMuxSource  Receive Mux value (Tx mux value is assumed to be rxMuxSource+1)
    */
   Spi0(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel, uint8_t rxMuxSource=USBDM::DMA0_SLOT_SPI0_Receive) :
      Spi_T<Spi0Info, Spi1_PCS0>(dmaTxChannel, dmaRxChannel, rxMuxSource) {
      NVIC_EnableIRQ(Spi0Info::irqNums[0]);
      NVIC_SetPriority(Spi0Info::irqNums[0], 2);

      spi->C2 |= SPI_C2_MODFEN_MASK|SPI_C2_TXDMAE_MASK|SPI_C2_RXDMAE_MASK; // Hardware SS output (since SSOE will be set)
      spiC1BaseValue = SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK|SPI_C1_SSOE_MASK;
      setMode();
   }
};
#else
/**
 * @brief Class representing SPI0 interface without hardware PCS
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi0(new USBDM::DmaChannel0(), new USBDM::DmaChannel1(), USBDM::DMA_SLOT_SPI0_Receive);
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 * @tparam  PCS...        Pcr used for PCSx
 */
class Spi0 : public Spi_T<Spi0Info> {

public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    * @param rxMuxSource  Receive Mux value (Tx mux value is assumed to be rxMuxSource+1)
    */
   Spi0(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel, uint8_t rxMuxSource=USBDM::DMA0_SLOT_SPI0_Receive) :
      Spi_T<Spi0Info>(dmaTxChannel, dmaRxChannel, rxMuxSource) {
      NVIC_EnableIRQ(Spi0Info::irqNums[0]);
      NVIC_SetPriority(Spi0Info::irqNums[0], 2);

      spi->C2 |= SPI_C2_TXDMAE_MASK|SPI_C2_RXDMAE_MASK;
      spiC1BaseValue = SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK;
      setMode();
   }
};
#endif

/**
 * @brief Template class representing SPI0 interface with GPIO used as select signal
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi0Gpio_T<USBDM::GpioC<3>, false>(new USBDM::DmaChannel0(), new USBDM::DmaChannel1());
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 * @tparam  Gpio        Gpio used as select signal
 * @tparam  enableValue Value used as selected level
 */
template<typename Gpio, bool enableValue=false>
class Spi0Gpio_T : public Spi0 {
public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    */
   Spi0Gpio_T(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel) :
      Spi0(dmaTxChannel, dmaRxChannel) {
   }
   /**
    *  Transmit and receive a series of bytes
    *
    *  @param dataSize  Number of bytes to transfer
    *  @param txData   Transmit bytes (may be NULL for Rx only)
    *  @param rxData    Receive byte buffer (may be NULL for Tx only)
    *
    *  Note: rxData may use same buffer as txData
    */
   virtual void txRxBytes(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=0) {
      Gpio::write(enableValue);
      Spi::txRxBytes(dataSize, txData, rxData=0);
      Gpio::write(!enableValue);
   }
   /**
    * Transmit and receive an 8-bit value over SPI
    *
    * @param data - Data to send
    *
    * @return Data received
    */
   virtual uint32_t txRx(uint32_t data) {
      Gpio::write(enableValue);
      uint32_t rv = Spi::txRx(data);
      Gpio::write(!enableValue);
      return rv;
   }
};
#endif // defined(USBDM_SPI0_IS_DEFINED) && (SPI0_SCK_PIN_SEL!=0) && (SPI0_MOSI_PIN_SEL!=0) && (SPI0_MISO_PIN_SEL!=0)

#if defined(USBDM_SPI1_IS_DEFINED) && (SPI1_SCK_PIN_SEL!=0) && (SPI1_MOSI_PIN_SEL!=0) && (SPI1_MISO_PIN_SEL!=0)
#if (SPI1_PCS0_PIN_SEL!=0)
/**
 * @brief Class representing SPI1 interface with hardware PCS
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi1pcs(new USBDM::DmaChannel0(), new USBDM::DmaChannel1(), USBDM::DMA_SLOT_SPI1_Receive);
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 */
class Spi1 : public Spi_T<Spi1Info, Spi1_PCS0> {

public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    * @param rxMuxSource  Receive Mux value (Tx mux value is assumed to be rxMuxSource+1)
    */
   Spi1(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel, uint8_t rxMuxSource=USBDM::DMA0_SLOT_SPI1_Receive) :
      Spi_T<Spi1Info, Spi1_PCS0>(dmaTxChannel, dmaRxChannel, rxMuxSource) {
      NVIC_EnableIRQ(Spi1Info::irqNums[0]);
      NVIC_SetPriority(Spi1Info::irqNums[0], 2);

      spi->C2 |= SPI_C2_MODFEN_MASK|SPI_C2_TXDMAE_MASK|SPI_C2_RXDMAE_MASK; // Hardware SS output (since SSOE will be set)
      spiC1BaseValue = SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK|SPI_C1_SSOE_MASK;
      setMode();
   }
};
#else
/**
 * @brief Class representing SPI1 interface without hardware PCS
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi1(new USBDM::DmaChannel0(), new USBDM::DmaChannel1(), USBDM::DMA_SLOT_SPI1_Receive);
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 * @tparam  PCS...        Pcr used for PCSx
 */
class Spi1 : public Spi_T<Spi1Info> {

public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    * @param rxMuxSource  Receive Mux value (Tx mux value is assumed to be rxMuxSource+1)
    */
   Spi1(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel, uint8_t rxMuxSource=USBDM::DMA0_SLOT_SPI1_Receive) :
      Spi_T<Spi1Info>(dmaTxChannel, dmaRxChannel, rxMuxSource) {
      NVIC_EnableIRQ(Spi1Info::irqNums[0]);
      NVIC_SetPriority(Spi1Info::irqNums[0], 2);

      spi->C2 |= SPI_C2_TXDMAE_MASK|SPI_C2_RXDMAE_MASK;
      spiC1BaseValue = SPI_C1_SPE_MASK|SPI_C1_MSTR_MASK;
      setMode();
   }
};
#endif

/**
 * @brief Template class representing SPI1 interface with GPIO used as select signal
 *
 * @code
 * USBDM::Spi *spi = new USBDM::Spi1Gpio_T<USBDM::GpioC<3>, false>(new USBDM::DmaChannel0(), new USBDM::DmaChannel1());
 *
 * uint8_t txData[] = {1,2,3,4};
 * uint8_t rxData[sizeof(txData)];
 *
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 * @tparam  Gpio        Gpio used as select signal
 * @tparam  enableValue Value used as selected level
 */
template<typename Gpio, bool enableValue=false>
class Spi1Gpio_T : public Spi1 {
public:
   /**
    * Constructor
    *
    * @param dmaTxChannel DMA Channel for transmission
    * @param dmaRxChannel DMA Channel for reception
    */
   Spi1Gpio_T(USBDM::DmaChannel *dmaTxChannel, USBDM::DmaChannel *dmaRxChannel) :
      Spi1(dmaTxChannel, dmaRxChannel) {
   }
   /**
    *  Transmit and receive a series of bytes
    *
    *  @param dataSize  Number of bytes to transfer
    *  @param txData   Transmit bytes (may be NULL for Rx only)
    *  @param rxData    Receive byte buffer (may be NULL for Tx only)
    *
    *  Note: rxData may use same buffer as txData
    */
   virtual void txRxBytes(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=0) {
      Gpio::write(enableValue);
      Spi::txRxBytes(dataSize, txData, rxData=0);
      Gpio::write(!enableValue);
   }
   /**
    * Transmit and receive an 8-bit value over SPI
    *
    * @param data - Data to send
    *
    * @return Data received
    */
   virtual uint32_t txRx(uint32_t data) {
      Gpio::write(enableValue);
      uint32_t rv = Spi::txRx(data);
      Gpio::write(!enableValue);
      return rv;
   }
};
#endif // defined(USBDM_SPI1_IS_DEFINED) && (SPI1_SCK_PIN_SEL!=0) && (SPI1_MOSI_PIN_SEL!=0) && (SPI1_MISO_PIN_SEL!=0)
/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_SPI_H_ */
