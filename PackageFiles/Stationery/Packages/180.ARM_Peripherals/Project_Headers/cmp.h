/**
 * @file     cmp.h (180.ARM_Peripherals/Project_Headers/cmp.h)
 * @brief    Analogue Comparator
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_CMP_H_
#define HEADER_CMP_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

/**
 * Filter Sample Count
 *
 * Represents the number of consecutive samples that must agree
 * prior to the comparator output filter accepting a new output state
 */
enum CmpFilterSamples {
   CmpFilterSamples_None = CMP_CR0_FILTER_CNT(0), //!< No filtering - Illegal when sampling is enabled.
   CmpFilterSamples_1    = CMP_CR0_FILTER_CNT(1), //!< 1 sample must agree
   CmpFilterSamples_2    = CMP_CR0_FILTER_CNT(2), //!< 2 samples must agree
   CmpFilterSamples_3    = CMP_CR0_FILTER_CNT(3), //!< 3 samples must agree
   CmpFilterSamples_4    = CMP_CR0_FILTER_CNT(4), //!< 4 samples must agree
   CmpFilterSamples_5    = CMP_CR0_FILTER_CNT(5), //!< 5 samples must agree
   CmpFilterSamples_6    = CMP_CR0_FILTER_CNT(6), //!< 6 samples must agree
   CmpFilterSamples_7    = CMP_CR0_FILTER_CNT(7), //!< 7 samples must agree
};

/**
 * Determines hysteresis of comparator
 */
enum CmpHysteresis {
   CmpHysteresis_0 = CMP_CR0_HYSTCTR(0), //!< Minimum.
   CmpHysteresis_1 = CMP_CR0_HYSTCTR(1), //!< Middle-low
   CmpHysteresis_2 = CMP_CR0_HYSTCTR(2), //!< Middle-high
   CmpHysteresis_3 = CMP_CR0_HYSTCTR(3), //!< Maximum.
};

/**
 * Comparator interrupt selection
 */
enum CmpInterrupt {
   CmpInterrupt_None    = CMP_SCR_IER(0)|CMP_SCR_IEF(0),  //!< Neither edge
   CmpInterrupt_Rising  = CMP_SCR_IER(1)|CMP_SCR_IEF(0),  //!< Rising edge
   CmpInterrupt_Falling = CMP_SCR_IER(0)|CMP_SCR_IEF(1),  //!< Falling edge
   CmpInterrupt_Both    = CMP_SCR_IER(1)|CMP_SCR_IEF(1),  //!< Rising or falling edge
};

/**
 * Comparator event identification
 */
enum CmpEvent {
   CmpEvent_None    = CMP_SCR_CFR(0)|CMP_SCR_CFF(0),  //!< Neither edge
   CmpEvent_Rising  = CMP_SCR_CFR(1)|CMP_SCR_CFF(0),  //!< Rising edge
   CmpEvent_Falling = CMP_SCR_CFR(0)|CMP_SCR_CFF(1),  //!< Falling edge
   CmpEvent_Both    = CMP_SCR_CFR(1)|CMP_SCR_CFF(1),  //!< Rising or falling edge
};

/**
 * Used to represent the comparator status for interrupt handler
 */
struct CmpStatus {
   CmpEvent event;   //!< Event triggering handler
   bool     state;   //!< State of CMPO at event
};

/**
 * Comparator mode
 */
enum CmpFilterClockSource {
   CmpFilterClockSource_internal = CMP_CR1_SE(0),  //!< Internal filter clock
   CmpFilterClockSource_external = CMP_CR1_SE(1),  //!< External filter clock
};

/**
 * Comparator mode
 */
enum CmpWindow {
   CmpWindow_Disabled = CMP_CR1_WE(0),  //!< Windowing disabled
   CmpWindow_Enabled  = CMP_CR1_WE(1),  //!< Windowing enabled
};

/**
 * Comparator power select
 */
enum CmpPower {
   CmpPower_LowPower    = CMP_CR1_PMODE(0), //!< Low power
   CmpPower_HighSpeed   = CMP_CR1_PMODE(1), //!< High speed
};

/**
 * Comparator invert
 */
enum CmpPolarity {
   CmpPolarity_Noninverted  = CMP_CR1_INV(0), //!< Not inverted
   CmpPolarity_Inverted     = CMP_CR1_INV(1), //!< Inverted
};

/**
 * Comparator output select
 */
enum CmpOutput {
   CmpOutput_Disabled  = CMP_CR1_OPE(0)|CMP_CR1_COS(0), //!< Disabled
   CmpOutput_Direct    = CMP_CR1_OPE(1)|CMP_CR1_COS(1), //!< Direct (unfiltered) output
   CmpOutput_Filtered  = CMP_CR1_OPE(1)|CMP_CR1_COS(0), //!< Filtered output
};

/**
 * Comparator mode
 */
enum CmpMode {
   CmpMode_Disabled    = CMP_CR1_EN(0),  //!< Disabled
   CmpMode_Enabled     = CMP_CR1_EN(1),  //!< Continuous
};

/**
 * DAC reference source
 */
enum CmpDacSource {
   CmpDacSource_Vin1 = CMP_DACCR_VRSEL(0), //!< Select Vrin1
   CmpDocSource_Vref = CmpDacSource_Vin1,  //!< Select Vrin1 = Vref_out
   CmpDacSource_Vin2 = CMP_DACCR_VRSEL(1), //!< Select Vrin2
   CmpDacSource_Vdd  = CmpDacSource_Vin2,  //!< Select Vrin2 = Vdd
};

/**
 * Type definition for CMP interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*CMPCallbackFunction)(CmpStatus status);

/**
 * Template class representing a Voltage Reference
 *
 * @tparam info      Information class for CMP
 *
 * @code
 *  // Example using an interrupt handler on both rising and falling edges
 *
 *  // Connections - change as required
 *  using Cmp = USBDM::Cmp0;
 *
 *  Cmp::configure(CmpPower_HighSpeed);
 *  Cmp::setDacLevel(20);
 *  Cmp::setCallback(callback);
 *  Cmp::enableInterrupts(CmpInterrupt_Both);
 *
 * @endcode
 */
template<class Info>
class CmpBase_T {

protected:
   /**
    * Callback to catch unhandled interrupt
    *
    * @param[in] status Struct indicating interrupt source and state
    */
   static void unhandledChannelCallback(CmpStatus status) {
      (void)status;
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static CMPCallbackFunction callback;

   /**
    * Clock register for peripheral
    *
    * @return Reference to clock register
    */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static __attribute__((always_inline)) volatile CMP_Type &cmp() { return Info::cmp(); }

   /**
    * IRQ handler
    */
   static void irqHandler() {
      int status = cmp().SCR&(CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK|CMP_SCR_COUT_MASK);

      // Clear interrupt
      cmp().SCR |= status;

      // Create status from snapshot
      CmpStatus cmpStatus{(CmpEvent)(status&(CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK)),(bool)(status&CMP_SCR_COUT_MASK)};

      // Call handler
      callback(cmpStatus);
   }

   /**
    * Set callback function
    *
    * @param[in]  theCallback Callback function to execute on interrupt
    */
   static void setCallback(CMPCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         theCallback = unhandledChannelCallback;
      }
      callback = theCallback;
   }
public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Basic enable CMP.
    * Includes enabling clock and configuring all pins of mapPinsOnEnable is selected on configuration
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to CMP interface
      clockReg() |= Info::clockMask;
   }

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Initialise hardware
      cmp().CR0   = Info::cr0;
      cmp().CR1   = Info::cr1 | CMP_CR1_EN_MASK;
      cmp().FPR   = Info::fpr;
      cmp().SCR   = Info::scr;
      cmp().DACCR = Info::daccr;
      cmp().MUXCR = Info::muxcr;

      enableNvicInterrupts();
   }

   /**
    * Configure all input pins associated with this CMP
    * The pins are set to analogue mode so no PCR settings are active.
    * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
    */
   static void setInputs() {
      configureAllPins();
   }

   /**
    * Configure pin associated with CMP input.
    * The pin is set to analogue mode so no PCR settings are active.\n
    * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
    *
    * @tparam cmpPin Number of comparator input (0-7) for associated pin being configured.
    */
   template<unsigned cmpPin>
   static void setInput() {
      using Pcr = PcrTable_T<Info, cmpPin>;

      // Map pin to CMP_OUT
      Pcr::setPCR(Info::info[cmpPin].pcrValue);
   }

   /**
    * Enable comparator output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding MUX value). See pcrValue()
    */
   static void setOutput(PcrValue pcrValue=GPIO_DEFAULT_PCR) {
      using Pcr = PcrTable_T<Info, 8>;

      // Enable and map pin to CMP_OUT
      cmp().CR1 |= CMP_CR1_OPE_MASK;
      Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[8].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Enable comparator output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
         ) {
      setOutput(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /*
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 1  Disabled                              0      X      X      X              X
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    * 3a   Sampled, Non-Filtered, external     1      0      1      1              X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1             >0     COUTA combinational, COUT sampled by busclk/PFR
    * 4a   Sampled, Filtered, external         1      0      1     >1              X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >1             >0     COUTA combinational, COUT filtered by busclk/PFR
    * 5a/b Windowed                            1      1      0      0              0     COUT == COUTA clocked by bus clock when Window=1
    * 6    Windowed, Re-sampled                1      1      0      1             >0     COUTA clocked by bus clock when Window=1, COUT re-sampled
    * 7    Windowed, Filtered                  1      1      0     >1             >0     COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    */

   /**
    * Base configuration - Continuous sampling: Modes 2a/2b.
    * Includes configuring all pins
    *
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    *
    * @param cmpPower        Power level. Tradeoff between speed and power consumption
    * @param cmpHysteresis   Hysteresis level for analogue comparator
    * @param cmpPolarity     Allows inversion of the comparator output
    */
   static void configure(
         CmpPower       cmpPower       = CmpPower_HighSpeed,
         CmpHysteresis  cmpHysteresis  = CmpHysteresis_2,
         CmpPolarity    cmpPolarity    = CmpPolarity_Noninverted
         ) {
      enable();

      // Initialise hardware
      cmp().CR1   = CmpMode_Enabled|cmpPower|cmpPolarity;
      cmp().CR0   = CmpFilterSamples_None|cmpHysteresis;
      cmp().FPR   = 0;
      cmp().SCR   = CMP_SCR_DMAEN(0)|CMP_SCR_IER(0)|CMP_SCR_IEF(0);
      cmp().DACCR = (CMP_DACCR_VOSEL_MASK>>1)&CMP_DACCR_VOSEL_MASK;
      cmp().MUXCR = Info::muxcr;
   }

   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static void selectInputs(unsigned positiveInput, unsigned negativeInput) {
      usbdm_assert((positiveInput<=7)&&(negativeInput<=7),"Illegal comparator input");

      //! MUX Control Register
      cmp().MUXCR =
         CMP_MUXCR_PSEL(positiveInput)| // Plus Input Mux Control
         CMP_MUXCR_MSEL(negativeInput); // Minus Input Mux Control
   }

   /**
    * Set Continuous input - Mode 2a/b.
    * Assumes basic configuration done
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    */
   static void setInputContinous() {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|CmpFilterSamples_None;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpFilterClockSource_internal|CmpWindow_Disabled;
      cmp().FPR = 0;
   }

   /**
    * Set Sampled, Non-Filtered input - Modes 3a/3b.
    * Assumes basic configuration done
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 3a   Sampled, Non-Filtered, external     1      0      1      1              X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1             >0     COUTA combinational, COUT sampled by busclk/PFR
    *
    * @param[in] cmpFilterClockSource     Filter clock source
    * @param[in] cmpFilterSamplePeriod  Period of internal sample filter. \n
    *                                     Only applicable if cmpFilterSamplesClockSource_internal and >0
    */
   static void setInputSampled(
         CmpFilterClockSource  cmpFilterClockSource,
         int                   cmpFilterSamplePeriod=1
         ) {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|CmpFilterSamples_1;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|cmpFilterClockSource|CmpWindow_Disabled;
      cmp().FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Sampled, Filtered input - Modes 4a/4b.
    * Assumes basic configuration done
    *
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 4a   Sampled, Filtered, external         1      0      1     >1              X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >1             >0     COUTA combinational, COUT filtered by busclk/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>1)
    * @param[in] cmpFilterClockSource     Filter clock source
    * @param[in] cmpFilterSamplePeriod   Period of internal sample filter. \n
    *                                     Only applicable if CmpFilterClockSource_internal and >0
    */
   static void setInputFiltered(
         CmpFilterSamples      cmpFilterSamples,
         CmpFilterClockSource  cmpFilterClockSource=CmpFilterClockSource_internal,
         int                   cmpFilterSamplePeriod=1
         ) {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|cmpFilterClockSource|CmpWindow_Disabled;
      cmp().FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Windowed input - Modes 5a/5b.
    * Assumes basic configuration done
    *
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 5a/b Windowed                            1      1      0      0              0     COUT == COUTA clocked by bus clock when Window=1
    */
   static void setInputWindowed() {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|0;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpFilterClockSource_internal|CmpWindow_Enabled;
      cmp().FPR = 0;
   }

   /**
    * Set Windowed, Re-sampled input - mode 6.
    * Assumes basic configuration done
    *
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 6    Windowed, Re-sampled                1      1      0      1             >0     COUTA clocked by bus clock when Window=1, COUT re-sampled
    *
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter.
    */
   static void setInputWindowedResampled(
         int                   cmpFilterSamplePeriod=1
         ) {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|CmpFilterSamples_1;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpFilterClockSource_internal|CmpWindow_Enabled;
      cmp().FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Windowed, Filtered input - mode 7.
    * Assumes basic configuration done
    *
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 7    Windowed, Filtered                  1      1      0     >1             >0     COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>1).
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (>0).
    */
   static void setInputWindowedFiltered(
         CmpFilterSamples     cmpFilterSamples,
         int                  cmpFilterSamplePeriod=1
         ) {
      cmp().CR0 = (cmp().CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      cmp().CR1 = (cmp().CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpFilterClockSource_internal|CmpWindow_Enabled;
      cmp().FPR = cmpFilterSamplePeriod;
   }

   static void enableWindowMode() {
      cmp().CR1 |= CMP_CR1_WE_MASK;
   }

   static void enableFilterMode() {
      cmp().CR1 |= CMP_CR1_WE_MASK;
   }

   /**
    * Set input filtering and hysteresis
    *
    * @param[in] cmpFilterSamples Filtering clock pulses
    * @param[in] cmpHysteresis    Hysteresis level
    */
   static void setInputConditioning(CmpFilterSamples cmpFilterSamples, CmpHysteresis cmpHysteresis) {
      cmp().CR0 = cmpFilterSamples|cmpHysteresis;
   }

   /**
    * Disable Cmp
    */
   static void disable() {
      cmp().CR1 = 0;
      clockReg() &= ~Info::clockMask;
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param[in]  enable        True => enable, False => disable
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(bool enable=true, uint32_t nvicPriority=NvicPriority_Normal) {

      if (enable) {
         enableNvicInterrupt(Info::irqNums[0], nvicPriority);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }

   /**
    * Enable/disable edge interrupts
    *
    * @param[in]  cmpInterrupt Controls edge selection
    */
   static void enableInterrupts(CmpInterrupt cmpInterrupt) {
      cmp().SCR = (cmp().SCR&~(CMP_SCR_IER_MASK|CMP_SCR_IEF_MASK))|cmpInterrupt;
   }

   /**
    * Enable/disable rising edge interrupts
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableRisingEdgeInterrupts(bool enable=true) {
      if (enable) {
         cmp().SCR |= CMP_SCR_IER_MASK;
      }
      else {
         cmp().SCR &= ~CMP_SCR_IER_MASK;
      }
   }

   /**
    * Enable/disable falling edge interrupts
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableFallingEdgeInterrupts(bool enable=true) {
      if (enable) {
         cmp().SCR |= CMP_SCR_IEF_MASK;
      }
      else {
         cmp().SCR &= ~CMP_SCR_IEF_MASK;
      }
   }

   /**
    * Enable/disable DMA requests
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableDmaRequests(bool enable=true) {
      if (enable) {
         cmp().SCR |= CMP_SCR_DMAEN_MASK;
      }
      else {
         cmp().SCR &= ~CMP_SCR_DMAEN_MASK;
      }
   }

   /**
    * Clear edge interrupt flags
    */
   static void clearInterruptFlags() {
      cmp().SCR |= CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK;
   }

   /**
    * Enable and configure DAC
    *
    * @param[in]  level        DAC level to select (0..63)
    * @param[in]  cmpDacSource Reference source select
    */
   static void configureDac(
         uint8_t       level,
         CmpDacSource  cmpDacSource) {
      cmp().DACCR = CMP_DACCR_DACEN_MASK|cmpDacSource|CMP_DACCR_VOSEL(level);
   }

   /**
    * Enable DAC
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableDAC(bool enable = true) {
      if (enable) {
         cmp().DACCR |= CMP_DACCR_DACEN_MASK;
      }
      else {
         cmp().DACCR &= ~CMP_DACCR_DACEN_MASK;
      }
   }

   /**
    * Set DAC level\n
    * Assumes the DAC has already been configured by configureDac()
    *
    * @param[in]  level  DAC level to select (0..63)
    */
   static void setDacLevel(uint8_t level) {
      cmp().DACCR = (cmp().DACCR&~CMP_DACCR_VOSEL_MASK) | CMP_DACCR_VOSEL(level);
   }

};

template<class Info> CMPCallbackFunction CmpBase_T<Info>::callback = CmpBase_T<Info>::unhandledChannelCallback;

#if defined(USBDM_CMP_IS_DEFINED)
using Cmp = CmpBase_T<CmpInfo>;
#endif

#if defined(USBDM_CMP0_IS_DEFINED)
/**
 * Select CMP0 inputs
 */
enum Cmp0Input {
   Cmp0Input_CmpIn0  = 0, //!< Cmp external pin 0
   Cmp0Input_CmpIn1  = 1, //!< Cmp external pin 1
   Cmp0Input_CmpIn2  = 2, //!< Cmp external pin 2
   Cmp0Input_CmpIn3  = 3, //!< Cmp external pin 3
   Cmp0Input_CmpIn4  = 4, //!< Cmp external pin 4
   Cmp0Input_VRefOut = 5, //!< Vref Output
   Cmp0Input_Bandgap = 6, //!< Internal Band-gap
   Cmp0Input_DacRef  = 7, //!< 6-bit dac0 reference
};

class Cmp0 : public CmpBase_T<Cmp0Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp0Input positiveInput, Cmp0Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif

#if defined(USBDM_CMP1_IS_DEFINED)
/**
 * Select CMP1 inputs
 */
enum Cmp1Input {
   Cmp1Input_CmpIn0  = 0, //!< Cmp external pin 0
   Cmp1Input_CmpIn1  = 1, //!< Cmp external pin 1
   Cmp1Input_CmpIn2  = 2, //!< Cmp external pin 2
   Cmp1Input_CmpIn3  = 3, //!< Cmp external pin 3
   Cmp1Input_CmpIn4  = 4, //!< Cmp external pin 4
   Cmp1Input_VRefOut = 5, //!< Vref Output
   Cmp1Input_Bandgap = 6, //!< Internal Band-gap
   Cmp1Input_DacRef  = 7, //!< 6-bit dac1 reference
};

class Cmp1 : public CmpBase_T<Cmp1Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp1Input positiveInput, Cmp1Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif

#if defined(USBDM_CMP2_IS_DEFINED)
/**
 * Select CMP2 inputs
 */
enum Cmp2Input {
   Cmp2Input_CmpIn0  = 0, //!< Cmp external pin 0
   Cmp2Input_CmpIn1  = 1, //!< Cmp external pin 1
   Cmp2Input_CmpIn2  = 2, //!< Cmp external pin 2
   Cmp2Input_CmpIn3  = 3, //!< Cmp external pin 3
   Cmp2Input_CmpIn4  = 4, //!< Cmp external pin 4
   Cmp2Input_VRefOut = 5, //!< Vref Output
   Cmp2Input_Bandgap = 6, //!< Internal Band-gap
   Cmp2Input_DacRef  = 7, //!< 6-bit dac1 reference
};

class Cmp2 : public CmpBase_T<Cmp2Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp2Input positiveInput, Cmp2Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif

#if defined(USBDM_CMP3_IS_DEFINED)
/**
 * Select CMP3 inputs
 */
enum Cmp3Input {
   Cmp3Input_CmpIn0  = 0, //!< Cmp external pin 0
   Cmp3Input_CmpIn1  = 1, //!< Cmp external pin 1
   Cmp3Input_CmpIn2  = 2, //!< Cmp external pin 2
   Cmp3Input_CmpIn3  = 3, //!< Cmp external pin 3
   Cmp3Input_CmpIn4  = 4, //!< Cmp external pin 4
   Cmp3Input_VRefOut = 5, //!< Vref Output
   Cmp3Input_Bandgap = 6, //!< Internal Band-gap
   Cmp3Input_DacRef  = 7, //!< 6-bit dac1 reference
};

class Cmp2 : public CmpBase_T<Cmp3Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp3Input positiveInput, Cmp3Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif
/**
 * End CMP_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMP_H_ */
