/**
 * @file     can.h (180.ARM_Peripherals/Project_Headers/can.h)
 *
 * @brief    Abstraction layer for CAN interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef PROJECT_HEADERS_CAN_H_
#define PROJECT_HEADERS_CAN_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup CAN_Group CAN, Digital-to-Analogue Converter
 * @brief Pins used for Digital-to-Analogue Converter
 * @{
 */
/**
 * Type definition for CAN interrupt call back
 */
typedef void (*CANCallbackFunction)(void);

/**
 * @brief Class representing a Digital to Analogue Converter
 *
 * <b>Example</b>
 * @code
 * using can = Can_T<Can0Info>;
 *
 *  vref::configure();
 *
 * @endcode
 */
template<class Info>
class Can_T {
protected:

   /** Callback functions for ISRs */
   static CANCallbackFunction callback[Info::irqCount];

public:
   /** CAN interrupt handler -  Calls CAN0 callback */
   static void irqHandler() {
      // Clear interrupt flag
      if (Can_T::callback[0] != 0) {
         Can_T::callback[0]();
      }
   }

public:
   /**
    * Set callback for ISR
    *
    * @param channel  The CAN channel to modify
    * @param callback The function to call from stub ISR
    */
   static void setCallback(int channel, CANCallbackFunction callback) {
      Can_T::callback[channel] = callback;
   }

protected:
   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile CAN_Type &can() { return Info::can(); }

   /** Clock register for peripheral */
   static __attribute__((always_inline)) volatile uint32_t &clockReg() { return Info::clockReg(); }

public:
   /**
    *  Configure the CAN with default settings
    *
    *  @param c0       Module Control Register 0
    *  @param c1       Module Control Register 1
    *  @param c2       Module Control Register 2
    */
   static void enable(uint32_t c0=Info::c0, uint32_t c1=Info::c1, uint32_t c2=Info::c2) {
      // Enable clock
      clockReg() |= Info::clockMask;
      __DMB();

      Info::initPCRs();

      // Enable timer
      can().C0 = c0|CAN_C0_CANEN_MASK;
      can().C1 = c1;
      can().C2 = c2;
   }
   
   /**
    *   Disable the CAN channel
    */
   static void finalise(uint8_t channel) {
      // Enable timer
      can().C0 = 0;
      can().C1 = 0;
      clockReg() &= ~Info::clockMask;
   }
   
   /**
    * Enable interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    */
   static void enableNvicInterrupts() {
      enableNvicInterrupt(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

};

/**
 * Callback table for programmatically set handlers
 */
template<class Info> CANCallbackFunction Can_T<Info>::callback[] = {0};

#if defined(USBDM_CAN0_IS_DEFINED)
using Can0 = Can_T<Can0Info>;
#endif

#if defined(USBDM_CAN1_IS_DEFINED)
using Can1 = Can_T<Can1Info>;
#endif
/**
 * @}
 */
} // End namespace USBDM

#endif /* PROJECT_HEADERS_CAN_H_ */
