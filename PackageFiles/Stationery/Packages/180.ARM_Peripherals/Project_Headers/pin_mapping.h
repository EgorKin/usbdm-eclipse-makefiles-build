/**
 * @file      pin_mapping.h (derived from S32K144.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for FS32K144HAT0MLHT
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

#if defined(PCC)

/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, (IRQn_Type)-1};

#if defined(PCC_PCC_PORTA_CGC_MASK)
/** Port information for PORTA*/
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, (uint32_t)&PCC->PCC_PORTA, PORTA_IRQn};
#endif

#if defined(PCC_PCC_PORTB_CGC_MASK)
/** Port information for PORTB*/
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, (uint32_t)&PCC->PCC_PORTB, PORTB_IRQn};
#endif

#if defined(PCC_PCC_PORTC_CGC_MASK)
/** Port information for PORTC*/
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, (uint32_t)&PCC->PCC_PORTC, PORTC_IRQn};
#endif

#if defined(PCC_PCC_PORTD_CGC_MASK)
/** Port information for PORTD*/
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, (uint32_t)&PCC->PCC_PORTD, PORTD_IRQn};
#endif

#if defined(PCC_PCC_PORTE_CGC_MASK)
/** Port information for PORTE*/
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, (uint32_t)&PCC->PCC_PORTE, PORTE_IRQn};
#endif

#if defined(PCC_PCC_PORTF_CGC_MASK)
/** Port information for PORTF*/
constexpr PortInfo  __attribute__((unused)) PortFInfo {PORTF_BasePtr, (uint32_t)&PCC->PCC_PORTF, PORTF_IRQn};
#endif

#if defined(PCC_PCC_PORTG_CGC_MASK)
/** Port information for PORTG*/
constexpr PortInfo  __attribute__((unused)) PortGInfo {PORTG_BasePtr, (uint32_t)&PCC->PCC_PORTG, PORTG_IRQn};
#endif

#else // defined(PCC)
/** Dummy port information for pins without an associated PCR */
constexpr PortInfo  __attribute__((unused)) NoPortInfo {0, 0, (IRQn_Type)-1};

#ifdef SIM_SCGC5_PORTA_MASK
/** Port information for PORTA */
constexpr PortInfo  __attribute__((unused)) PortAInfo {PORTA_BasePtr, SIM_SCGC5_PORTA_MASK, PORTA_IRQn};
#endif

#ifdef SIM_SCGC5_PORTB_MASK
/** Port information for PORTB */
constexpr PortInfo  __attribute__((unused)) PortBInfo {PORTB_BasePtr, SIM_SCGC5_PORTB_MASK, PORTB_IRQn};
#endif

#ifdef SIM_SCGC5_PORTC_MASK
/** Port information for PORTC */
constexpr PortInfo  __attribute__((unused)) PortCInfo {PORTC_BasePtr, SIM_SCGC5_PORTC_MASK, PORTC_IRQn};
#endif

#ifdef SIM_SCGC5_PORTD_MASK
/** Port information for PORTD */
constexpr PortInfo  __attribute__((unused)) PortDInfo {PORTD_BasePtr, SIM_SCGC5_PORTD_MASK, PORTD_IRQn};
#endif

#ifdef SIM_SCGC5_PORTE_MASK
/** Port information for PORTE */
constexpr PortInfo  __attribute__((unused)) PortEInfo {PORTE_BasePtr, SIM_SCGC5_PORTE_MASK, PORTE_IRQn};
#endif

#endif // defined(PCC)

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
};

/** Enables mapping of all allocated pins during startup using mapAllPins() */
static constexpr bool MAP_ALL_PINS = false;

/** Used to configure pin-mapping before 1st use of peripherals */
extern void mapAllPins();

/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = RTC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile RTC_Type &rtc() {
      return *(RTC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      RTC_IRQn, RTC_Seconds_IRQn, };

   // Template:rtc_s32k14x

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   2: RTC_CLKOUT           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: RTC_CLKIN            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SimInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SIM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SIM_Type &sim() {
      return *(SIM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:sim_s32k142

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup PCC_Group PCC, Peripheral Clock Control
 * @brief Abstraction for Peripheral Clock Control
 * @{
 */
#define USBDM_PCC_IS_DEFINED
/**
 * Peripheral information for PCC, Peripheral Clock Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Clock sources using first dividers

    * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
    * - SIRC_CLK = Output clock of Slow IRC.
    * - FIRC_CLK = Output clock of Fast IRC.
    * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
    */
   enum Div1ClockSource {
      Div1ClockSource_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
      Div1ClockSource_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
      Div1ClockSource_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SPLLDIV[SOSCDIV1]
      Div1ClockSource_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[FIRCDIV1]
      Div1ClockSource_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV1]
      Div1ClockSource_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
      Div1ClockSource_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
      Div1ClockSource_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV1]
      Div1ClockSource_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
   };

   /**
    * Clock sources using second dividers

    * - SOSC_CLK = System oscillator clock. Either EXTAL or oscillator. See SCG_SOSCCFG[EREFS].
    * - SIRC_CLK = Output clock of Slow IRC.
    * - FIRC_CLK = Output clock of Fast IRC (Nominally 48MHz).
    * - SPLL_CLK = Output of PLL (VCO_CLK / 2)
    */
   enum Div2ClockSource {
      Div2ClockSource_Disabled   = PCC_PCCn_CGC(0)|PCC_PCCn_PCD(0), //!< Disabled
      Div2ClockSource_Reserved0  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(0), //!< Disabled
      Div2ClockSource_Sosc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(1), //!< SOSC_CLK divided by SCG_SPLLDIV[SOSCDIV2]
      Div2ClockSource_Sirc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(2), //!< SIRC_CLK divided by SCG_SIRCDIV[FIRCDIV2]
      Div2ClockSource_Firc       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(3), //!< FIRC_CLK divided by SCG_FIRCDIV[FIRCDIV2]
      Div2ClockSource_Reserved4  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(4), //!< Disabled
      Div2ClockSource_Reserved5  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(5), //!< Disabled
      Div2ClockSource_Spll       = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(6), //!< SPLL_CLK divided by SCG_SPLLDIV[SPLLDIV2]
      Div2ClockSource_Reserved7  = PCC_PCCn_CGC(1)|PCC_PCCn_PCD(7), //!< Disabled
   };

class PccInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PCC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PCC_Type &pcc() {
      return *(PCC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:pcc_s32k144

   /**
    * Get clock frequency for peripheral using the Divide-by-1 clock sources
    *
    * @param div1ClockSource Clock source selector as used by PCC->PCCn
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getDivideBy1Clock(Div1ClockSource div1ClockSource) {
      switch(div1ClockSource&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         default:
         case Div1ClockSource_Disabled: return 0; // Disabled
         case Div1ClockSource_Spll:     return 0; // SPLLDIV1
         case Div1ClockSource_Firc:     return 0; // FIRCDIV1
         case Div1ClockSource_Sirc:     return 0; // SIRCDIV1
         case Div1ClockSource_Sosc:     return 0; // SOSCDIV1
      }
   }

   /**
    * Get clock frequency for peripheral using the Divide-by-2 clock sources
    *
    * @param div2ClockSource Clock source selector as used by PCC->PCCn
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getDivideBy2Clock(Div2ClockSource div2ClockSource) {
      switch(div2ClockSource&(PCC_PCCn_CGC_MASK|PCC_PCCn_PCD_MASK)) {
         default:
         case Div2ClockSource_Disabled: return 0; // Disabled
         case Div2ClockSource_Spll:     return 0; // SPLLDIV2
         case Div2ClockSource_Firc:     return 0; // FIRCDIV2
         case Div2ClockSource_Sirc:     return 0; // SIRCDIV2
         case Div2ClockSource_Sosc:     return 0; // SOSCDIV2
      }
   }

#ifdef PCC_PCC_ADC0_CGC_MASK
   /**
    * Set ADC0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setAdc0Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_ADC0 = 0;
      pcc().PCC_ADC0 = div2ClockSource;
   }

   /**
    * Get ADC0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getAdc0Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_ADC0);
   }
#endif

#ifdef PCC_PCC_ADC1_CGC_MASK
   /**
    * Set ADC1 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setAdc1Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_ADC1 = 0;
      pcc().PCC_ADC1 = div2ClockSource;
   }

   /**
    * Get ADC1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getAdc1Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_ADC1);
   }
#endif

#ifdef PCC_PCC_FLEXIO_CGC_MASK
   /**
    * Set FLEXIO input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setFlexioClock(Div2ClockSource div2ClockSource) {
      pcc().PCC_FLEXIO = 0;
      pcc().PCC_FLEXIO = div2ClockSource;
   }

   /**
    * Get FLEXIO input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFlexioClock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_FLEXIO);
   }
#endif

#ifdef PCC_PCC_LPUART0_CGC_MASK
   /**
    * Set LPUART0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpuart0Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPUART0 = 0;
      pcc().PCC_LPUART0 = div2ClockSource;
   }

   /**
    * Get LPUART0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuart0Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPUART0);
   }
#endif

#ifdef PCC_PCC_LPUART1_CGC_MASK
   /**
    * Set LPUART1 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpuart1Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPUART1 = 0;
      pcc().PCC_LPUART1 = div2ClockSource;
   }

   /**
    * Get LPUART1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuart1Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPUART1);
   }
#endif

#ifdef PCC_PCC_LPUART2_CGC_MASK
   /**
    * Set LPUART2 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpuart2Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPUART2 = 0;
      pcc().PCC_LPUART2 = div2ClockSource;
   }

   /**
    * Get LPUART2 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuart2Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPUART2);
   }
#endif

#ifdef PCC_PCC_LPSPI0_CGC_MASK
   /**
    * Set LPSPI0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpspi0Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPSPI0 = 0;
      pcc().PCC_LPSPI0 = div2ClockSource;
   }

   /**
    * Get LPSPI0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpspi0Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPSPI0);
   }
#endif

#ifdef PCC_PCC_LPSPI1_CGC_MASK
   /**
    * Set LPSPI1 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpspi1Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPSPI1 = 0;
      pcc().PCC_LPSPI1 = div2ClockSource;
   }

   /**
    * Get LPSPI1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpspi1Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPSPI1);
   }
#endif

#ifdef PCC_PCC_LPSPI2_CGC_MASK
   /**
    * Set LPSPI2 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpspi2Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPSPI2 = 0;
      pcc().PCC_LPSPI2 = div2ClockSource;
   }

   /**
    * Get LPSPI2 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpspi2Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPSPI2);
   }
#endif

#ifdef PCC_PCC_LPI2C0_CGC_MASK
   /**
    * Set LPI2C0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpi2c0Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPI2C0 = 0;
      pcc().PCC_LPI2C0 = div2ClockSource;
   }

   /**
    * Get LPI2C0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpi2c0Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPI2C0);
   }
#endif

#ifdef PCC_PCC_LPI2C1_CGC_MASK
   /**
    * Set LPI2C1 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpi2c1Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPI2C1 = 0;
      pcc().PCC_LPI2C1 = div2ClockSource;
   }

   /**
    * Get LPI2C1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpi2c1Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPI2C1);
   }
#endif

#ifdef PCC_PCC_LPI2C2_CGC_MASK
   /**
    * Set LPI2C2 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpi2c2Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPI2C2 = 0;
      pcc().PCC_LPI2C2 = div2ClockSource;
   }

   /**
    * Get LPI2C2 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpi2c2Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPI2C2);
   }
#endif

#ifdef PCC_PCC_LPIT_CGC_MASK
   /**
    * Set LPIT input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLpitClock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPIT = 0;
      pcc().PCC_LPIT = div2ClockSource;
   }

   /**
    * Get LPIT input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpitClock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPIT);
   }
#endif

#ifdef PCC_PCC_LPTMR0_CGC_MASK
   /**
    * Set LPTMR0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setLptmr0Clock(Div2ClockSource div2ClockSource) {
      pcc().PCC_LPTMR0 = 0;
      pcc().PCC_LPTMR0 = div2ClockSource;
   }

   /**
    * Get LPTMR0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLptmr0Clock() {
      return getDivideBy2Clock((Div2ClockSource)pcc().PCC_LPTMR0);
   }
#endif

#ifdef PCC_PCC_FTM0_CGC_MASK
   /**
    * Set FTM0 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setFtm0Clock(Div1ClockSource div1ClockSource) {
      pcc().PCC_FTM0 = 0;
      pcc().PCC_FTM0 = div1ClockSource;
   }

   /**
    * Get FTM0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFtm0Clock() {
      return getDivideBy1Clock((Div1ClockSource)pcc().PCC_FTM0);
   }
#endif

#ifdef PCC_PCC_FTM1_CGC_MASK
   /**
    * Set FTM1 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setFtm1Clock(Div1ClockSource div1ClockSource) {
      pcc().PCC_FTM1 = 0;
      pcc().PCC_FTM1 = div1ClockSource;
   }

   /**
    * Get FTM1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFtm1Clock() {
      return getDivideBy1Clock((Div1ClockSource)pcc().PCC_FTM1);
   }
#endif

#ifdef PCC_PCC_FTM2_CGC_MASK
   /**
    * Set FTM2 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setFtm2Clock(Div1ClockSource div1ClockSource) {
      pcc().PCC_FTM2 = 0;
      pcc().PCC_FTM2 = div1ClockSource;
   }

   /**
    * Get FTM2 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFtm2Clock() {
      return getDivideBy1Clock((Div1ClockSource)pcc().PCC_FTM2);
   }
#endif

#ifdef PCC_PCC_FTM3_CGC_MASK
   /**
    * Set FTM3 input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setFtm3Clock(Div1ClockSource div1ClockSource) {
      pcc().PCC_FTM3 = 0;
      pcc().PCC_FTM3 = div1ClockSource;
   }

   /**
    * Get FTM3 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getFtm3Clock() {
      return getDivideBy1Clock((Div1ClockSource)pcc().PCC_FTM3);
   }
#endif

#ifdef PCC_PCC_ENET_CGC_MASK
   /**
    * Set ENET input clock source
    *
    * @param div2ClockSource Clock source selection
    */
   static void setEnetClock(Div1ClockSource div1ClockSource) {
      pcc().PCC_ENET = 0;
      pcc().PCC_ENET = div1ClockSource;
   }

   /**
    * Get ENET input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getEnetClock() {
      return getDivideBy1Clock((Div1ClockSource)pcc().PCC_ENET);
   }
#endif

};

/** 
 * End group PCC_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Adc0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = ADC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile ADC_Type &adc() {
      return *(ADC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      ADC0_IRQn, };

   // Template:adc0_s32k142

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(0)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADIV(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_SMPLTS(99);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_ADC0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_ADC0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: ADC0_SE0             = PTA0 (50)                      */  { PortAInfo,  GPIOA_BasePtr,  0,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   1: ADC0_SE1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: ADC0_SE2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: ADC0_SE3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: ADC0_SE4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: ADC0_SE10            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: ADC0_SE11            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  12: ADC0_SE12            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  13: ADC0_SE13            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: ADC0_SE14            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);

#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);

#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x1U);
   }

};

#define USBDM_ADC1_IS_DEFINED
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Adc1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = ADC1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile ADC_Type &adc() {
      return *(ADC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      ADC1_IRQn, };

   // Template:adc0_s32k142

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(0)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADIV(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_SMPLTS(99);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_ADC1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_ADC1 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: ADC1_SE0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: ADC1_SE1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: ADC1_SE2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: ADC1_SE3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: ADC1_SE4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: ADC1_SE5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: ADC1_SE6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: ADC1_SE7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: ADC1_SE8             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: ADC1_SE9             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: ADC1_SE10            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: ADC1_SE11            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  12: ADC1_SE12            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  13: ADC1_SE13            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  14: ADC1_SE14            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  15: ADC1_SE15            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CAN_Group CAN, Controller Area Network
 * @brief Abstraction for Controller Area Network
 * @{
 */
#define USBDM_CAN0_IS_DEFINED
/**
 * Peripheral information for CAN, Controller Area Network.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Can0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CAN0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CAN_Type &can() {
      return *(CAN_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 5;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CAN0_ORed_IRQn, CAN0_Error_IRQn, CAN0_Wake_Up_IRQn, CAN0_ORed_0_15_MB_IRQn, 
      CAN0_ORed_16_31_MB_IRQn, };

   // Template:can0_s32k14x

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FlexCAN0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FlexCAN0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CAN0_RX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CAN0_TX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CAN1_IS_DEFINED
/**
 * Peripheral information for CAN, Controller Area Network.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Can1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CAN1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CAN_Type &can() {
      return *(CAN_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 3;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CAN1_ORed_IRQn, CAN1_Error_IRQn, CAN1_ORed_0_15_MB_IRQn, };

   // Template:can1_s32k14x

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FlexCAN1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FlexCAN1 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CAN1_RX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CAN1_TX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CAN2_IS_DEFINED
/**
 * Peripheral information for CAN, Controller Area Network.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Can2Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CAN2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CAN_Type &can() {
      return *(CAN_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 3;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CAN2_ORed_IRQn, CAN2_Error_IRQn, CAN2_ORed_0_15_MB_IRQn, };

   // Template:can1_s32k14x

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FlexCAN2 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FlexCAN2 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CAN2_RX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: CAN2_TX              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CAN_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CMP0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CMP_Type &cmp() {
      return *(CMP_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      CMP0_IRQn, };

   // Template:cmp0_mke16f16

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_CMP0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_CMP0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: CMP0_IN0             = PTA0 (50)                      */  { PortAInfo,  GPIOA_BasePtr,  0,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   1: CMP0_IN1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: CMP0_IN4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: CMP0_IN5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: CMP0_IN6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: CMP0_IN7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: CMP0_OUT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: CMP0_RRT             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);

#endif
      PORTA->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0001UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
#ifdef PCC_PCCn_CGC_MASK
      PCC->PCC_PORTA = PCC_PCCn_CGC_MASK;
#else
      enablePortClocks(PORTA_CLOCK_MASK);

#endif
      PORTA->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x1U);
   }

};

/** 
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   // Template:control

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: JTAG_TMS             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: SWD_DIO              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: RESET_b              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: JTAG_TDO             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: noetm_TRACE_SWO      = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: CLKOUT               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: JTAG_TCLK            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: SWD_CLK              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: JTAG_TDI             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: NMI_b                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CRC_Group CRC, Cyclic Redundancy Check
 * @brief Abstraction for Cyclic Redundancy Check
 * @{
 */
#define USBDM_CRC0_IS_DEFINED
/**
 * Peripheral information for CRC, Cyclic Redundancy Check.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Crc0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = CRC0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile CRC_Type &crc() {
      return *(CRC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:crc0_0x40032000

   static constexpr uint32_t gpoly =  0;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_CRC |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_CRC &= ~PCC_PCCn_CGC_MASK;
   }

};

/** 
 * End group CRC_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED
/**
 * Peripheral information for DMA, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dma0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = DMA0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DMA_Type &dma() {
      return *(DMA_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 17;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      DMA0_IRQn, DMA1_IRQn, DMA2_IRQn, DMA3_IRQn, 
      DMA4_IRQn, DMA5_IRQn, DMA6_IRQn, DMA7_IRQn, 
      DMA8_IRQn, DMA9_IRQn, DMA10_IRQn, DMA11_IRQn, 
      DMA12_IRQn, DMA13_IRQn, DMA14_IRQn, DMA15_IRQn, 
      DMA_Error_IRQn, };

   // Template:dma0_16ch_ears16

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Number of DMA channels implemented
   static constexpr unsigned NumChannels = 16;

   //! Number of DMA vectors implemented
   static constexpr unsigned NumVectors = 16;

};

/** 
 * End group DMA_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dmamux0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = DMAMUX0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile DMAMUX_Type &dmamux() {
      return *(DMAMUX_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:dmamux0_16ch_trig

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_DMAMUX |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_DMAMUX &= ~PCC_PCCn_CGC_MASK;
   }

   // Number of DMA channels implemented
   static constexpr unsigned NumChannels = 16;

   static constexpr uint8_t chcfg0_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg1_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg2_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg3_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg4_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg5_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg6_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg7_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg8_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg9_source  = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg10_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg11_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg12_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg13_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg14_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg15_source = DMAMUX_CHCFG_SOURCE(0);
};

/** 
 * End group DMAMUX_Group
 * @}
 */
/**
 * @addtogroup ENET_Group ENET, Unknown
 * @brief Abstraction for Unknown
 * @{
 */
/** 
 * End group ENET_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED
/**
 * Peripheral information for EWM, External Watchdog Monitor.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class EwmInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = EWM_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile EWM_Type &ewm() {
      return *(EWM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      WDOG_EWM_IRQn, };

   // Template:ewm_int_pr

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_EWM |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_EWM &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: EWM_IN               = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: EWM_OUT_b            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group EWM_Group
 * @}
 */
/**
 * @addtogroup FLEXIO_Group FLEXIO, Flexible I/O
 * @brief Abstraction for Flexible I/O
 * @{
 */
#define USBDM_FLEXIO_IS_DEFINED
/**
 * Peripheral information for FLEXIO, Flexible I/O.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FlexioInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FLEXIO_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FLEXIO_Type &flexio() {
      return *(FLEXIO_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FLEXIO_IRQn, };

   // Template:flexio_4sh_4tmr_mke15z7

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FXIO_D0              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FXIO_D1              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FXIO_D2              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FXIO_D3              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FXIO_D4              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FXIO_D5              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FXIO_D6              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FXIO_D7              = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group FLEXIO_Group
 * @}
 */
/**
 * @addtogroup FTFC_Group FTFC, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
#define USBDM_FTFC_IS_DEFINED
/**
 * Peripheral information for FTFC, Flash Memory Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtfcInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTFC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTFC_Type &ftfc() {
      return *(FTFC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 3;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTFC_IRQn, Read_Collision_IRQn, FTFC_Fault_IRQn, };

   // Template:ftfc_s32k14x

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FTFC |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FTFC &= ~PCC_PCCn_CGC_MASK;
   }

};

/** 
 * End group FTFC_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_FTM_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {
public:
   // Template:ftm

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: TCLK1                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: TCLK0                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: TCLK2                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_FTM0_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 6;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM0_Ch0_Ch1_IRQn, FTM0_Ch2_Ch3_IRQn, FTM0_Ch4_Ch5_IRQn, FTM0_Ch6_Ch7_IRQn, 
      FTM0_Fault_IRQn, FTM0_Ovf_Reload_IRQn, };

   // Template:ftm0_8ch_s32k144

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FTM0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FTM0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM0_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM0_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM0_CH2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FTM0_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM0_CH4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FTM0_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM0_CH6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FTM0_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM0_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM0_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 6;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM1_Ch0_Ch1_IRQn, FTM1_Ch2_Ch3_IRQn, FTM1_Ch4_Ch5_IRQn, FTM1_Ch6_Ch7_IRQn, 
      FTM1_Fault_IRQn, FTM1_Ovf_Reload_IRQn, };

   // Template:ftm0_8ch_s32k144

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FTM1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FTM1 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM1_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM1_CH2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FTM1_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM1_CH4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FTM1_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM1_CH6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FTM1_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM1_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM1_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM1_FLT1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: FTM1_FLT2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: FTM1_FLT3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

#define USBDM_FTM1_INFOQUAD_IS_DEFINED
   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM2_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm2Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 6;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM2_Ch0_Ch1_IRQn, FTM2_Ch2_Ch3_IRQn, FTM2_Ch4_Ch5_IRQn, FTM2_Ch6_Ch7_IRQn, 
      FTM2_Fault_IRQn, FTM2_Ovf_Reload_IRQn, };

   // Template:ftm0_8ch_s32k144

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FTM2 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FTM2 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM2_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM2_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM2_CH2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FTM2_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM2_CH4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FTM2_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM2_CH6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FTM2_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM2_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM2_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM2_FLT1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: FTM2_FLT2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: FTM2_FLT3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

#define USBDM_FTM2_INFOQUAD_IS_DEFINED
   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM2_QD_PHA          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM2_QD_PHB          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM3_IS_DEFINED
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm3Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = FTM3_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile FTM_Type &ftm() {
      return *(FTM_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 6;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      FTM3_Ch0_Ch1_IRQn, FTM3_Ch2_Ch3_IRQn, FTM3_Ch4_Ch5_IRQn, FTM3_Ch6_Ch7_IRQn, 
      FTM3_Fault_IRQn, FTM3_Ovf_Reload_IRQn, };

   // Template:ftm0_8ch_s32k144

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Modulo
   static constexpr uint32_t modulo = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0x0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** Minimum resolution for PWM interval */
   static constexpr uint32_t minimumResolution=100;

   /** Minimum usable interval in ticks */      
   static constexpr uint32_t minimumInterval=20;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm().SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_FTM3 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_FTM3 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: FTM3_CH0             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: FTM3_CH1             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: FTM3_CH2             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: FTM3_CH3             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: FTM3_CH4             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: FTM3_CH5             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: FTM3_CH6             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: FTM3_CH7             = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

#define USBDM_FTM3_INFOFAULT_IS_DEFINED
   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PinInfo  info[] = {
   
            //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
            /*   0: FTM3_FLT0            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   1: FTM3_FLT1            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   2: FTM3_FLT2            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
            /*   3: FTM3_FLT3            = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {
public:
   // Template:gpioa_s32k

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortAInfo, GPIOA_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

#define USBDM_GPIOB_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioBInfo {
public:
   // Template:gpioa_s32k

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortBInfo, GPIOB_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

#define USBDM_GPIOC_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioCInfo {
public:
   // Template:gpioa_s32k

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortCInfo, GPIOC_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

#define USBDM_GPIOD_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioDInfo {
public:
   // Template:gpioa_s32k

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortDInfo, GPIOD_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

#define USBDM_GPIOE_IS_DEFINED
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioEInfo {
public:
   // Template:gpioa_s32k

   //! Describes the port/gpio
   static constexpr PinInfo pinInfo { PortEInfo, GPIOE_BasePtr, 0, GPIO_DEFAULT_PCR  };
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup LPI2C_Group LPI2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_LPI2C0_IS_DEFINED
/**
 * Peripheral information for LPI2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpi2c0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPI2C0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPI2C_Type &lpi2c() {
      return *(LPI2C_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPI2C0_Master_IRQn, LPI2C0_Slave_IRQn, };

   // Template:lpi2c0_s32k14x

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPI2C0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPI2C0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPI2C0_SCL           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPI2C0_SDA           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   4: LPI2C0_SCLS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: LPI2C0_SDAS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: LPI2C0_HREQ          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPI2C_Group
 * @}
 */
/**
 * @addtogroup LPIT_Group LPIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
#define USBDM_LPIT0_IS_DEFINED
/**
 * Peripheral information for LPIT, Programmable Interrupt Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpit0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPIT0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPIT_Type &lpit() {
      return *(LPIT_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPIT0_Ch0_IRQn, LPIT0_Ch1_IRQn, LPIT0_Ch2_IRQn, LPIT0_Ch3_IRQn, };

   // Template:lpit0

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPIT |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPIT &= ~PCC_PCCn_CGC_MASK;
   }

};

/** 
 * End group LPIT_Group
 * @}
 */
/**
 * @addtogroup LPSPI_Group LPSPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
#define USBDM_LPSPI0_IS_DEFINED
/**
 * Peripheral information for LPSPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpspi0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPSPI0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPSPI_Type &lpspi() {
      return *(LPSPI_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPSPI0_IRQn, };

   // Template:lpspi0

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPSPI0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPSPI0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPSPI0_SCK           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPSPI0_SIN           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPSPI0_SOUT          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPSPI0_PCS0          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: LPSPI0_PCS1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: LPSPI0_PCS2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: LPSPI0_PCS3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_LPSPI1_IS_DEFINED
/**
 * Peripheral information for LPSPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpspi1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPSPI1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPSPI_Type &lpspi() {
      return *(LPSPI_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPSPI1_IRQn, };

   // Template:lpspi0

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPSPI1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPSPI1 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPSPI1_SCK           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPSPI1_SIN           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPSPI1_SOUT          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPSPI1_PCS0          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: LPSPI1_PCS1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: LPSPI1_PCS2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: LPSPI1_PCS3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_LPSPI2_IS_DEFINED
/**
 * Peripheral information for LPSPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpspi2Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPSPI2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPSPI_Type &lpspi() {
      return *(LPSPI_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPSPI2_IRQn, };

   // Template:lpspi0

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPSPI2 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPSPI2 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPSPI2_SCK           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPSPI2_SIN           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPSPI2_SOUT          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPSPI2_PCS0          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: LPSPI2_PCS1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: LPSPI2_PCS2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: LPSPI2_PCS3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPSPI_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lptmr0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPTMR_Type &lptmr() {
      return *(LPTMR_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPTMR0_IRQn, };

   // Template:lptmr0_dma

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPTMR0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPTMR0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPTMR0_ALT3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPUART0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPUART_Type &lpuart() {
      return *(LPUART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPUART0_RxTx_IRQn, };

   // Template:lpuart0_mke_fifo

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
   #if defined(PCC_PCC_LPUART0_CGC_MASK)
      return PccInfo::getLpuart0Clock();
   #elif defined(SIM_SOPT2_LPUART0SRC_MASK)
      return SimInfo::getLpuart0Clock();
   #else
      return SimInfo::getLpuartClock();
   #endif
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPUART0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPUART0 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPUART0_TX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPUART0_RX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPUART0_RTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPUART0_CTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_LPUART1_IS_DEFINED
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPUART1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPUART_Type &lpuart() {
      return *(LPUART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPUART1_RxTx_IRQn, };

   // Template:lpuart0_mke_fifo

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
   #if defined(PCC_PCC_LPUART1_CGC_MASK)
      return PccInfo::getLpuart0Clock();
   #elif defined(SIM_SOPT2_LPUART1SRC_MASK)
      return SimInfo::getLpuart1Clock();
   #else
      return SimInfo::getLpuartClock();
   #endif
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPUART1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPUART1 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPUART1_TX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPUART1_RX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPUART1_RTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPUART1_CTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_LPUART2_IS_DEFINED
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lpuart2Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = LPUART2_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile LPUART_Type &lpuart() {
      return *(LPUART_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LPUART2_RxTx_IRQn, };

   // Template:lpuart0_mke_fifo

   //! Number of samples per bit
   static constexpr uint32_t oversampleRatio = 8;

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;

   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;

   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
   #if defined(PCC_PCC_LPUART2_CGC_MASK)
      return PccInfo::getLpuart0Clock();
   #elif defined(SIM_SOPT2_LPUART2SRC_MASK)
      return SimInfo::getLpuart2Clock();
   #else
      return SimInfo::getLpuartClock();
   #endif
   }

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_LPUART2 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_LPUART2 &= ~PCC_PCCn_CGC_MASK;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: LPUART2_TX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: LPUART2_RX           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: LPUART2_RTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: LPUART2_CTS          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPUART_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Abstraction for Programmable Delay Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED
/**
 * Peripheral information for PDB, Programmable Delay Block.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Pdb0Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PDB0_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PDB_Type &pdb() {
      return *(PDB_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      PDB0_IRQn, };

   // Template:pdb0_2ch_8pt_0dac_1po

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint32_t pdb_sc = 
      PDB_SC_MULT(0) |      // Multiplication Factor Select for Prescaler
      PDB_SC_PDBIE(0) |     // Interrupt Enable
      PDB_SC_TRGSEL(0) |    // Trigger Input Source Select
      PDB_SC_PRESCALER(0) | // Prescaler Divider Select
      PDB_SC_DMAEN(0) |     // DMA Enable
      PDB_SC_CONT(0) |     // Continuous Mode Enable
      PDB_SC_PDBEIE(0) |    // Sequence Error Interrupt Enable
      PDB_SC_LDMOD(0);      // Load Mode Select

   static constexpr uint32_t pdb_mod = 
      PDB_MOD_MOD(65535);  // PDB Modulus

   static constexpr uint32_t pdb_idly = 
      PDB_IDLY_IDLY(0);  // Counter Modulus

   struct PdbChannel {
      uint32_t c1;
      uint32_t dly0;
      uint32_t dly1;
   };

   // Number of PDB channels
   static constexpr size_t numChannels = 2;

   // Default values for channel registers
   static constexpr PdbChannel pdb_ch[numChannels] = {
   {                   // Channel[0] Control Register 1
      PDB_C1_BB(0x0) |   // Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 1
   },
   {                   // Channel[1] Control Register 1
      PDB_C1_BB(0x0) |   // Channel Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Channel Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Channel Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 1
   },
   };

   // Number of DACs
   static constexpr size_t numDacs = 0;

   static constexpr uint32_t pdb_poen = 
      PDB_POEN_POEN(0x0);   // Pulse-Out Enable

   // Number of PDB pulse outputs
   static constexpr size_t numPulseOutputs = 4;

   static constexpr uint32_t pdb_podly[numPulseOutputs] = {
      // Pulse Output[0] Delays {
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // Pulse Output[1] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // PDB Pulse Output[2] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // PDB Pulse Output[3] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2
   }; 

   /**
     * Get PDB clock frequency
     *
     * @return Frequency as a uint32_t in Hz
     */
   static __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_PDB0 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_PDB0 &= ~PCC_PCCn_CGC_MASK;
   }

};

#define USBDM_PDB1_IS_DEFINED
/**
 * Peripheral information for PDB, Programmable Delay Block.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Pdb1Info {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PDB1_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PDB_Type &pdb() {
      return *(PDB_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      PDB1_IRQn, };

   // Template:pdb0_2ch_8pt_0dac_1po

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   static constexpr uint32_t pdb_sc = 
      PDB_SC_MULT(0) |      // Multiplication Factor Select for Prescaler
      PDB_SC_PDBIE(0) |     // Interrupt Enable
      PDB_SC_TRGSEL(0) |    // Trigger Input Source Select
      PDB_SC_PRESCALER(0) | // Prescaler Divider Select
      PDB_SC_DMAEN(0) |     // DMA Enable
      PDB_SC_CONT(0) |     // Continuous Mode Enable
      PDB_SC_PDBEIE(0) |    // Sequence Error Interrupt Enable
      PDB_SC_LDMOD(0);      // Load Mode Select

   static constexpr uint32_t pdb_mod = 
      PDB_MOD_MOD(65535);  // PDB Modulus

   static constexpr uint32_t pdb_idly = 
      PDB_IDLY_IDLY(0);  // Counter Modulus

   struct PdbChannel {
      uint32_t c1;
      uint32_t dly0;
      uint32_t dly1;
   };

   // Number of PDB channels
   static constexpr size_t numChannels = 2;

   // Default values for channel registers
   static constexpr PdbChannel pdb_ch[numChannels] = {
   {                   // Channel[0] Control Register 1
      PDB_C1_BB(0x0) |   // Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 1
   },
   {                   // Channel[1] Control Register 1
      PDB_C1_BB(0x0) |   // Channel Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0x0) |  // Channel Pre-Trigger Output Select
      PDB_C1_EN(0x0),    // Channel Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 1
   },
   };

   // Number of DACs
   static constexpr size_t numDacs = 0;

   static constexpr uint32_t pdb_poen = 
      PDB_POEN_POEN(0x0);   // Pulse-Out Enable

   // Number of PDB pulse outputs
   static constexpr size_t numPulseOutputs = 4;

   static constexpr uint32_t pdb_podly[numPulseOutputs] = {
      // Pulse Output[0] Delays {
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // Pulse Output[1] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // PDB Pulse Output[2] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // PDB Pulse Output[3] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2
   }; 

   /**
     * Get PDB clock frequency
     *
     * @return Frequency as a uint32_t in Hz
     */
   static __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   /** 
    *  Enable clock to peripheral
    */
   __attribute__((always_inline)) static void enableClock() {
      PCC->PCC_PDB1 |= PCC_PCCn_CGC_MASK;
   }

   /** 
    *  Disable clock to peripheral
    */
   __attribute__((always_inline)) static void disableClock() {
      PCC->PCC_PDB1 &= ~PCC_PCCn_CGC_MASK;
   }

};

/** 
 * End group PDB_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
#define USBDM_PMC_IS_DEFINED
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PmcInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = PMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile PMC_Type &pmc() {
      return *(PMC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      LVD_LVW_IRQn, };

   // Template:pmc_s32k14x

   //! Default value for Low Voltage Detect Status And Control 1 register
   static constexpr uint32_t pmc_lvdsc1  = 
   #ifdef PMC_LVDSC1_LVDV
      PMC_LVDSC1_LVDV(0)   | // Low-Voltage Detect Voltage Select
   #endif
      PMC_LVDSC1_LVDIE(0) | // Low-Voltage Detect Interrupt Enable
      PMC_LVDSC1_LVDRE(0);  // Low-Voltage Detect Reset Enable

   //! Default value for Low Voltage Detect Status And Control 2 register
   static constexpr uint32_t pmc_lvdsc2  = 
   #ifdef PMC_LVDSC2_LVWV
      PMC_LVDSC2_LVWV(0)   | // Low-Voltage Warning Voltage Select
   #endif
      PMC_LVDSC2_LVWIE(0);  // Low-Voltage Warning Interrupt Enable

   #ifdef PMC_REGSC_BGEN
   //! Default value for Regulator Status And Control register
   static constexpr uint32_t pmc_regsc  = 
      PMC_REGSC_BGEN(0) | // Bandgap Enable In VLPx Operation
      PMC_REGSC_BGBE(0);  // Bandgap Buffer Enable   

   #endif
   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

};

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: VDD                  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: VDDA                 = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: VREFH                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: VREFL                = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: VSS                  = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup QSPI_Group QSPI, Unknown
 * @brief Abstraction for Unknown
 * @{
 */
/** 
 * End group QSPI_Group
 * @}
 */
/**
 * @addtogroup SCG_Group SCG, System Clock Generator
 * @brief Abstraction for System Clock Generator
 * @{
 */
#define USBDM_SCG_IS_DEFINED
/**
 * Peripheral information for SCG, System Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ScgInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SCG_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SCG_Type &scg() {
      return *(SCG_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {
      SCG_IRQn, };

   // Template:scg_s32k14x

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (1 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  7;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   enum ClockMode {
      ClockMode_None     = -1,
      ClockMode_FIRC     = 0, // Reset state
      ClockMode_SOSC,
      ClockMode_SIRC,
      ClockMode_SYSPLL,
   };

   //! Frequency of Slow Internal Reference Clock [~32kHz]
   static constexpr uint32_t system_slow_irc_clock = 8000000UL;

   //! Frequency of Fast Internal Reference Clock [~4MHz]
   static constexpr uint32_t system_fast_irc_clock = 48000000UL;

   //! PLL VDIV min value
   static constexpr uint32_t pll_vdiv_min = 24;

   //! PLL post divider
   static constexpr uint32_t pll_post_divider = 1;

   //! Structure for clock configurations
   struct ClockInfo {
      //! Clock Mode
      const ClockMode clockMode;

      //! System OSC Control Status Register (LK, SOSCCMRE, SOSCCM, SOSCEN, )
      const uint32_t sosccsr;
      //! System OSC Divide Register (SOSCDIV2, SOSCDIV1)
      const uint32_t soscdiv;
      //! System OSC Configuration Register (RANGE, HGO, EREFS)
      const uint32_t sosccfg;

      //! Slow IRC Control Status Register (LK, SIRCLPEN, SIRCSTEN, SIRCEN)
      const uint32_t sirccsr;
      //! Slow IRC Divide Register (SIRCDIV2, SIRCDIV1)
      const uint32_t sircdiv;
      //! Slow IRC Configuration Register (RANGE)
      const uint32_t sirccfg;

      //! Fast IRC Control Status Register (LK, FIRCREGOFF, FIRCEN)
      const uint32_t firccsr;
      //! Fast IRC Divide Register (FIRCDIV2, FIRCDIV1)
      const uint32_t fircdiv;
      //! Fast IRC Configuration Register (RANGE)
      const uint32_t firccfg;

      //! System PLL Control Status Register (LK, SPLLCMRE, SPLLCM, SPLLEN)
      const uint32_t spllcsr;
      //! System PLL Divide Register (SPLLDIV2, SPLLDIV1)
      const uint32_t splldiv;
      //! System PLL Configuration Register (MULT, PREDIV)
      const uint32_t spllcfg;
   };

   /**
    * Get Fast Internal Reference Clock FIRC/DIV1
    *
    * @return Clock as uint32_t
    */
   static uint32_t getFastIrcClockDiv1() {
      return system_fast_irc_clock/(1<<((scg().FIRCDIV&SCG_FIRCDIV_FIRCDIV1_MASK)>>SCG_FIRCDIV_FIRCDIV1_SHIFT));
   }

   /**
    * Get Fast Internal Reference Clock FIRC/DIV2
    *
    * @return Clock as uint32_t
    */
   static uint32_t getFastIrcClockDiv2() {
      return system_fast_irc_clock/(1<<((scg().FIRCDIV&SCG_FIRCDIV_FIRCDIV2_MASK)>>SCG_FIRCDIV_FIRCDIV2_SHIFT));
   }

   /**
    * Get Slow Internal Reference Clock SIRC/DIV1
    *
    * @return Clock as uint32_t
    */
   static uint32_t getSlowIrcClockDiv1() {
      return system_slow_irc_clock/(1<<((scg().SIRCDIV&SCG_SIRCDIV_SIRCDIV1_MASK)>>SCG_SIRCDIV_SIRCDIV1_SHIFT));
   }

   /**
    * Get Slow Internal Reference Clock SIRC/DIV2
    *
    * @return Clock as uint32_t
    */
   static uint32_t getSlowIrcClockDiv2() {
      return system_slow_irc_clock/(1<<((scg().SIRCDIV&SCG_SIRCDIV_SIRCDIV2_MASK)>>SCG_SIRCDIV_SIRCDIV2_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: SCG_XTAL             = PTB6 (12)                      */  { PortBInfo,  GPIOB_BasePtr,  6,       PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   1: SCG_EXTAL            = PTB7 (11)                      */  { PortBInfo,  GPIOB_BasePtr,  7,       PORT_PCR_MUX(0)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClock(PORTB_CLOCK_MASK);

      PORTB->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x00C0UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClock(PORTB_CLOCK_MASK);

      PORTB->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xC0U);
   }

};

/** 
 * End group SCG_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
#define USBDM_SMC_IS_DEFINED
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SmcInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = SMC_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile SMC_Type &smc() {
      return *(SMC_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:smc_s32k14x

};

/** 
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup TRGMUX_Group TRGMUX, Trigger Multiplexor
 * @brief Abstraction for Trigger Multiplexor
 * @{
 */
#define USBDM_TRGMUX_IS_DEFINED
/**
 * Peripheral information for TRGMUX, Trigger Multiplexor.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class TrgmuxInfo {
public:
   //! Hardware base address as uint32_t 
   static constexpr uint32_t baseAddress = TRGMUX_BasePtr;

   //! Hardware base pointer
   __attribute__((always_inline)) static volatile TRGMUX_Type &trgmux() {
      return *(TRGMUX_Type *)baseAddress;
   }

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:trgmux_s32k142

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;

   //! Number of signals available in info table
   static constexpr int numSignals  = 24;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  portInfo    gpioAddress     gpioBit  PCR value
         /*   0: TRGMUX_IN0           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   1: TRGMUX_IN1           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   2: TRGMUX_IN2           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   3: TRGMUX_IN3           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   4: TRGMUX_IN4           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   5: TRGMUX_IN5           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   6: TRGMUX_IN6           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   7: TRGMUX_IN7           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   8: TRGMUX_IN8           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*   9: TRGMUX_IN9           = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  10: TRGMUX_IN10          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  11: TRGMUX_IN11          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  12: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  13: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  14: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  15: --                   = --                             */  { NoPortInfo, 0,         INVALID_PCR,  0 },
         /*  16: TRGMUX_OUT0          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  17: TRGMUX_OUT1          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  18: TRGMUX_OUT2          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  19: TRGMUX_OUT3          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  20: TRGMUX_OUT4          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  21: TRGMUX_OUT5          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  22: TRGMUX_OUT6          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
         /*  23: TRGMUX_OUT7          = --                             */  { NoPortInfo, 0,         UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group TRGMUX_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


#include "adc.h"
#include "ftm.h"
#include "gpio.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
using Adc_50               = const USBDM::Adc0Channel<0>;
/** 
 * End group ADC_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM

/**
 *
 * @page PinSummary Pin Mapping
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTA0                     | ADC0_SE0/CMP0_IN0                           | 50                        | -       
 *  PTA1                     | -                                           | 49                        | -       
 *  PTA2                     | -                                           | 48                        | -       
 *  PTA3                     | -                                           | 47                        | -       
 *  PTA4                     | -                                           | 64                        | -       
 *  PTA5                     | -                                           | 63                        | -       
 *  PTA6                     | -                                           | 38                        | -       
 *  PTA7                     | -                                           | 37                        | -       
 *  PTA10                    | -                                           | 58                        | -       
 *  PTA11                    | -                                           | 57                        | -       
 *  PTA12                    | -                                           | 56                        | -       
 *  PTA13                    | -                                           | 55                        | -       
 *  PTB0                     | -                                           | 34                        | -       
 *  PTB1                     | -                                           | 33                        | -       
 *  PTB2                     | -                                           | 32                        | -       
 *  PTB3                     | -                                           | 31                        | -       
 *  PTB4                     | -                                           | 19                        | -       
 *  PTB5                     | -                                           | 18                        | -       
 *  PTB6                     | SCG_XTAL                                    | 12                        | -       
 *  PTB7                     | SCG_EXTAL                                   | 11                        | -       
 *  PTB12                    | -                                           | 43                        | -       
 *  PTB13                    | -                                           | 42                        | -       
 *  PTC0                     | -                                           | 26                        | -       
 *  PTC1                     | -                                           | 25                        | -       
 *  PTC2                     | -                                           | 21                        | -       
 *  PTC3                     | -                                           | 20                        | -       
 *  PTC4                     | -                                           | 62                        | -       
 *  PTC5                     | -                                           | 61                        | -       
 *  PTC6                     | -                                           | 52                        | -       
 *  PTC7                     | -                                           | 51                        | -       
 *  PTC8                     | -                                           | 36                        | -       
 *  PTC9                     | -                                           | 35                        | -       
 *  PTC14                    | -                                           | 30                        | -       
 *  PTC15                    | -                                           | 29                        | -       
 *  PTC16                    | -                                           | 28                        | -       
 *  PTC17                    | -                                           | 27                        | -       
 *  PTD0                     | -                                           | 2                         | -       
 *  PTD1                     | -                                           | 1                         | -       
 *  PTD2                     | -                                           | 46                        | -       
 *  PTD3                     | -                                           | 45                        | -       
 *  PTD4                     | -                                           | 44                        | -       
 *  PTD5                     | -                                           | 24                        | -       
 *  PTD6                     | -                                           | 23                        | -       
 *  PTD7                     | -                                           | 22                        | -       
 *  PTD15                    | -                                           | 15                        | -       
 *  PTD16                    | -                                           | 14                        | -       
 *  PTE0                     | -                                           | 60                        | -       
 *  PTE1                     | -                                           | 59                        | -       
 *  PTE2                     | -                                           | 54                        | -       
 *  PTE3                     | -                                           | 13                        | -       
 *  PTE4                     | -                                           | 6                         | -       
 *  PTE5                     | -                                           | 5                         | -       
 *  PTE6                     | -                                           | 53                        | -       
 *  PTE7                     | -                                           | 39                        | -       
 *  PTE8                     | -                                           | 17                        | -       
 *  PTE9                     | -                                           | 16                        | -       
 *  PTE10                    | -                                           | 4                         | -       
 *  PTE11                    | -                                           | 3                         | -       
 *  VDD                      | -                                           | 7                         | -       
 *  VDD2                     | -                                           | 41                        | -       
 *  VDDA                     | -                                           | 8                         | -       
 *  VREFH                    | -                                           | 9                         | -       
 *  VSS                      | -                                           | 10                        | -       
 *  VSS1                     | -                                           | 40                        | -       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTD1                     | -                                           | 1                         | -       
 *  PTD0                     | -                                           | 2                         | -       
 *  PTE11                    | -                                           | 3                         | -       
 *  PTE10                    | -                                           | 4                         | -       
 *  PTE5                     | -                                           | 5                         | -       
 *  PTE4                     | -                                           | 6                         | -       
 *  VDD                      | -                                           | 7                         | -       
 *  VDDA                     | -                                           | 8                         | -       
 *  VREFH                    | -                                           | 9                         | -       
 *  VSS                      | -                                           | 10                        | -       
 *  PTB7                     | SCG_EXTAL                                   | 11                        | -       
 *  PTB6                     | SCG_XTAL                                    | 12                        | -       
 *  PTE3                     | -                                           | 13                        | -       
 *  PTD16                    | -                                           | 14                        | -       
 *  PTD15                    | -                                           | 15                        | -       
 *  PTE9                     | -                                           | 16                        | -       
 *  PTE8                     | -                                           | 17                        | -       
 *  PTB5                     | -                                           | 18                        | -       
 *  PTB4                     | -                                           | 19                        | -       
 *  PTC3                     | -                                           | 20                        | -       
 *  PTC2                     | -                                           | 21                        | -       
 *  PTD7                     | -                                           | 22                        | -       
 *  PTD6                     | -                                           | 23                        | -       
 *  PTD5                     | -                                           | 24                        | -       
 *  PTC1                     | -                                           | 25                        | -       
 *  PTC0                     | -                                           | 26                        | -       
 *  PTC17                    | -                                           | 27                        | -       
 *  PTC16                    | -                                           | 28                        | -       
 *  PTC15                    | -                                           | 29                        | -       
 *  PTC14                    | -                                           | 30                        | -       
 *  PTB3                     | -                                           | 31                        | -       
 *  PTB2                     | -                                           | 32                        | -       
 *  PTB1                     | -                                           | 33                        | -       
 *  PTB0                     | -                                           | 34                        | -       
 *  PTC9                     | -                                           | 35                        | -       
 *  PTC8                     | -                                           | 36                        | -       
 *  PTA7                     | -                                           | 37                        | -       
 *  PTA6                     | -                                           | 38                        | -       
 *  PTE7                     | -                                           | 39                        | -       
 *  VSS1                     | -                                           | 40                        | -       
 *  VDD2                     | -                                           | 41                        | -       
 *  PTB13                    | -                                           | 42                        | -       
 *  PTB12                    | -                                           | 43                        | -       
 *  PTD4                     | -                                           | 44                        | -       
 *  PTD3                     | -                                           | 45                        | -       
 *  PTD2                     | -                                           | 46                        | -       
 *  PTA3                     | -                                           | 47                        | -       
 *  PTA2                     | -                                           | 48                        | -       
 *  PTA1                     | -                                           | 49                        | -       
 *  PTA0                     | ADC0_SE0/CMP0_IN0                           | 50                        | -       
 *  PTC7                     | -                                           | 51                        | -       
 *  PTC6                     | -                                           | 52                        | -       
 *  PTE6                     | -                                           | 53                        | -       
 *  PTE2                     | -                                           | 54                        | -       
 *  PTA13                    | -                                           | 55                        | -       
 *  PTA12                    | -                                           | 56                        | -       
 *  PTA11                    | -                                           | 57                        | -       
 *  PTA10                    | -                                           | 58                        | -       
 *  PTE1                     | -                                           | 59                        | -       
 *  PTE0                     | -                                           | 60                        | -       
 *  PTC5                     | -                                           | 61                        | -       
 *  PTC4                     | -                                           | 62                        | -       
 *  PTA5                     | -                                           | 63                        | -       
 *  PTA4                     | -                                           | 64                        | -       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  VSS1                     | -                                           | 40                        | -       
 *  PTA0                     | ADC0_SE0/CMP0_IN0                           | 50                        | -       
 *  PTB7                     | SCG_EXTAL                                   | 11                        | -       
 *  PTB6                     | SCG_XTAL                                    | 12                        | -       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
