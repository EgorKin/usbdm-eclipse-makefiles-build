/**
 * @file     smc.h (180.ARM_Peripherals/Project_Headers/smc.h)
 * @brief    System Management Controller
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef SMC_H_
#define SMC_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/*
 * Determines if VLPR, VLPW, and VLPS modes are enabled
 */
enum SmcVeryLowPower {
   SmcVeryLowPower_Disable  = SMC_PMPROT_AVLP(0),   //!< Disallow VLPR, VLPW, and VLPS modes
   SmcVeryLowPower_Enable   = SMC_PMPROT_AVLP(1),   //!< Allow VLPR, VLPW, and VLPS modes
};

/*
 * Determines if any LLSx modes are enabled
 */
enum SmcLowLeakageStop {
   SmcLowLeakageStop_Disable  = SMC_PMPROT_ALLS(0),   //!< Disallow Any LLSx mode
   SmcLowLeakageStop_Enable   = SMC_PMPROT_ALLS(1),   //!< Allow Any LLSx mode
};

/*
 * Determines if any VLLSx modes are enabled
 */
enum SmcVeryLowLeakageStop {
   SmcVeryLowLeakageStop_Disable  = SMC_PMPROT_AVLLS(0),   //!< Disallow Any VLLSx mode
   SmcVeryLowLeakageStop_Enable   = SMC_PMPROT_AVLLS(1),   //!< Allow Any VLLSx mode
};

/*
 * Determines if HSRUN mode is enabled
 */
enum SmcHighSpeedRun {
#ifdef SMC_PMPROT_AHSRUN
   SmcHighSpeedRun_Disable  = SMC_PMPROT_AHSRUN(0),   //!< Disallow HSRUN mode
   SmcHighSpeedRun_Enable   = SMC_PMPROT_AHSRUN(1),   //!< Allow HSRUN mode
#else
   SmcHighSpeedRun_Disable  = 0, // Not supported
#endif
};

/**
 * Whether to exit to Run mode on interrupt
 */
enum SmcLowPowerWakeOnInt {
#ifdef SMC_PMCTRL_LPWUI
   SmcLowPowerWakeOnInt_Disable = SMC_PMCTRL_LPWUI(0),  //!< Remain in VLP mode on interrupt
   SmcLowPowerWakeOnInt_Enable  = SMC_PMCTRL_LPWUI(1),  //!< Exit to RUN mode on interrupt
#else
   SmcLowPowerWakeOnInt_Disable = 0, // Not supported
#endif
};

/**
 * Sets Run mode
 */
enum SmcRunMode {
   SmcRunMode_Normal       = SMC_PMCTRL_RUNM(0),   //!< Normal run mode (RUN)
   SmcRunMode_VeryLowPower = SMC_PMCTRL_RUNM(2),   //!< Very low power run mode (VLPR)
   SmcRunMode_HighSpeed    = SMC_PMCTRL_RUNM(3),   //!< High Speed Run mode (HSRUN)
};

/**
 * Sets Stop mode
 */
enum SmcStopMode {
   SmcStopMode_NormalStop         = SMC_PMCTRL_STOPM(0), //!< Normal Stop (STOP)
   SmcStopMode_VeryLowPowerStop   = SMC_PMCTRL_STOPM(2), //!< Very-Low-Power Stop (VLPS)
   SmcStopMode_LowLeakageStop     = SMC_PMCTRL_STOPM(3), //!< Low-Leakage Stop (LLSx)
   SmcStopMode_VeryLowLeakageStop = SMC_PMCTRL_STOPM(4), //!< Very-Low-Leakage Stop (VLLSx)
};

/**
 *  Partial Stop Option\n
 *  This field controls whether a Partial Stop mode is entered when STOPM=STOP\n
 *  Not all modes may be supported
 */
enum SmcPartialStopMode {
#ifdef SMC_STOPCTRL_PSTOPO
   SmcPartialStopMode_Normal   = SMC_STOPCTRL_PSTOPO(0), //!< Normal stop mode
   SmcPartialStopMode_Partial1 = SMC_STOPCTRL_PSTOPO(1), //!< Partial Stop with both system and bus clocks disabled
   SmcPartialStopMode_Partial2 = SMC_STOPCTRL_PSTOPO(2), //!< Partial Stop with system clock disabled and bus clock enabled
#endif
   SmcPartialStopMode_Normal   = 0, //!< No options supported
};

/**
 *  POR Power Option\n
 *  This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 */
enum SmcPowerOnReset {
   SmcPowerOnReset_Disable = SMC_STOPCTRL_PORPO(0),   //!< Power on reset in STOP disabled
   SmcPowerOnReset_Enable  = SMC_STOPCTRL_PORPO(1),   //!< Power on reset in STOP enabled
};

/**
 *  VLS or VLLS Mode Control\n
 *  This field controls which LLS/VLLS sub-mode to enter if STOPM=LLS/VLLS\n
 *  Not all modes may be supported
 */
enum SmcLowLeakageStopMode {
   SmcLowLeakageStopMode_VLLS0 = SMC_STOPCTRL_VLLSM(0),
   SmcLowLeakageStopMode_VLLS1 = SMC_STOPCTRL_VLLSM(1),
   SmcLowLeakageStopMode_VLLS2 = SMC_STOPCTRL_VLLSM(2),
   SmcLowLeakageStopMode_VLLS3 = SMC_STOPCTRL_VLLSM(3),
   SmcLowLeakageStopMode_LLS2  = SMC_STOPCTRL_LLSM(2),
   SmcLowLeakageStopMode_LLS3  = SMC_STOPCTRL_LLSM(3),
};

/**
 *  Indicates the current stop mode
 */
enum SmcStatus {
   // Run modes
   SmcStatus_hsrun  = SMC_PMSTAT_PMSTAT(1<<7),
   SmcStatus_run    = SMC_PMSTAT_PMSTAT(1<<0),
   SmcStatus_vlpr   = SMC_PMSTAT_PMSTAT(1<<2),

   // Sleep = Wait modes
   SmcStatus_vlpw   = SMC_PMSTAT_PMSTAT(1<<3),

   // Stop = DeepSleep modes
   SmcStatus_stop   = SMC_PMSTAT_PMSTAT(1<<1),
   SmcStatus_vlps   = SMC_PMSTAT_PMSTAT(1<<4),
   SmcStatus_lls    = SMC_PMSTAT_PMSTAT(1<<5),
   SmcStatus_vlls   = SMC_PMSTAT_PMSTAT(1<<6),
};

/**
 *  POR Power Option\n
 *  This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 */
enum SmcPowerOption {
   SmcPowerOption_Disable = SMC_VLLSCTRL_PORPO(0),
   SmcPowerOption_Enable  = SMC_VLLSCTRL_PORPO(1),
};

template <class Info>
class SmcBase_T {

protected:
   static constexpr volatile SMC_Type *smc = Info::smc;

public:

#ifndef SMC_PMCTRL_LPWUI
#define SMC_PMCTRL_LPWUI 0 // Not all target support this
#endif

   /**
    * Configure with settings from Configure.usbdmProject.
    */
   static void defaultConfigure() {
      smc->PMPROT   = Info::pmprot;
      smc->STOPCTRL = Info::stopctrl;
   }

   /**
    * Enable the given power modes.\n
    * A mode must be enabled before it can be entered.\n
    *
    * @param[in] smcVeryLowPower        Allows VLPR, VLPW, and VLPS modes
    * @param[in] smcLowLeakageStop      Allows LLSx modes
    * @param[in] smcVeryLowLeakageStop  Allows VLLSx modes
    * @param[in] smcHighSpeedRun        Allows HSRUN mode (if supported)
    *
    * @note This is a write-once-after-reset operation
    */
   static ErrorCode enablePowerModes(
         SmcVeryLowPower         smcVeryLowPower,
         SmcLowLeakageStop       smcLowLeakageStop       = SmcLowLeakageStop_Disable,
         SmcVeryLowLeakageStop   smcVeryLowLeakageStop   = SmcVeryLowLeakageStop_Disable,
         SmcHighSpeedRun         smcHighSpeedRun         = SmcHighSpeedRun_Disable ) {
      uint8_t mask = smcVeryLowPower|smcLowLeakageStop|smcVeryLowLeakageStop|smcHighSpeedRun;
      smc->PMPROT = mask;
      return E_NO_ERROR;
   }

   /**
    * Allows the detailed operation in STOP mode to be controlled.
    *
    * @param[in] smcLowLeakageStopMode  Controls which LLS/VLLS sub-mode to enter if STOPM=LLS/VLLS
    * @param[in] smcPowerOnReset        Controls whether the POR detect circuit is enabled in VLLS0 mode
    * @param[in] smcPartialStopMode     Controls whether a Partial Stop mode is entered when STOPM=STOP (is supported)
    */
   static void setStopOptions(
         SmcLowLeakageStopMode   smcLowLeakageStopMode,
         SmcPowerOnReset         smcPowerOnReset,
         SmcPartialStopMode      smcPartialStopMode=SmcPartialStopMode_Normal) {

      smc->STOPCTRL = smcPartialStopMode|smcPowerOnReset|smcLowLeakageStopMode;
   }

   /**
    * Get current power status
    *
    * @return SmcStatus value indicating operating mode
    */
   static SmcStatus getPowerStatus() {

      return smc->PMSTAT;
   }

   /**
    * Enter Run Mode
    *
    * @param[in]  smcRunMode  Mode to enter
    *
    * @return E_NO_ERROR                 No error
    * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to run mode from current run mode
    */
   static ErrorCode enterRunMode(SmcRunMode smcRunMode) {

      SmcStatus smcStatus = getPowerStatus();
      switch(smcRunMode) {
         case SmcRunMode_Normal:
            break;
         case SmcRunMode_HighSpeed:
         case SmcRunMode_VeryLowPower:
            if (smcStatus != SmcStatus_run) {
               // Can only transition from RUN mode
               return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
            }
            break;
         default:
            return setErrorCode(E_ILLEGAL_PARAM);
      }
      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
      return E_NO_ERROR;
   }

   /**
    * Set Stop Mode to enter on Sleep-Now or Sleep-On-Exit
    *
    * @param[in]  smcStopMode             Stop mode to set
    */
   static void setStopMode(SmcStopMode smcStopMode) {

      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_STOPM_MASK)|smcStopMode;
      // Make sure write completes
      (void)smc->PMCTRL;
   }

#ifdef SMC_PMCTRL_LPWUI_MASK
   /**
    * Set action on interrupt when in VLP modes (VLPR, VLPW or VLPS).
    *
    * @param[in]  smcLowPowerWakeOnInt    Whether to exit from any VLP to RUN mode in interrupt
    */
   static void setVlpInterruptAction(SmcLowPowerWakeOnInt smcLowPowerWakeOnInt) {

      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_LPWUI_MASK)|smcLowPowerWakeOnInt;
      // Make sure write completes
      (void)smc->PMCTRL;
   }
#else
   /**
    * Set action on interrupt when in VLP modes (VLPR, VLPW or VLPS).
    *
    * @param[in]  smcLowPowerWakeOnInt   Not supported
    *
    * @note Not supported
    */
   static void setVlpInterruptAction(SmcLowPowerWakeOnInt) {
   }

#endif

};

#ifdef USBDM_SMC_IS_DEFINED
/**
 * Class representing SMC
 */
using Smc = SmcBase_T<SmcInfo>;

#endif

} // End namespace USBDM

#endif /* SMC_H_ */
