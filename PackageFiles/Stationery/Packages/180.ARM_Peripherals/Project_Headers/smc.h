/**
 * @file     smc.h (180.ARM_Peripherals/Project_Headers/smc.h)
 * @brief    System Management Controller
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef SMC_H_
#define SMC_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */

/*
 * Determines if VLPR, VLPW, and VLPS modes are enabled
 */
enum SmcVeryLowPower {
   SmcVeryLowPower_Disable  = SMC_PMPROT_AVLP(0),   //!< Disallow VLPR, VLPW, and VLPS modes
   SmcVeryLowPower_Enable   = SMC_PMPROT_AVLP(1),   //!< Allow VLPR, VLPW, and VLPS modes
};

/*
 * Determines if any LLSx modes are enabled
 */
enum SmcLowLeakageStop {
   SmcLowLeakageStop_Disable  = SMC_PMPROT_ALLS(0),   //!< Disallow Any LLSx mode
   SmcLowLeakageStop_Enable   = SMC_PMPROT_ALLS(1),   //!< Allow Any LLSx mode
};

/*
 * Determines if any VLLSx modes are enabled
 */
enum SmcVeryLowLeakageStop {
   SmcVeryLowLeakageStop_Disable  = SMC_PMPROT_AVLLS(0),   //!< Disallow Any VLLSx mode
   SmcVeryLowLeakageStop_Enable   = SMC_PMPROT_AVLLS(1),   //!< Allow Any VLLSx mode
};

/*
 * Determines if HSRUN mode is enabled
 */
enum SmcHighSpeedRun {
#ifdef SMC_PMPROT_AHSRUN
   SmcHighSpeedRun_Disable  = SMC_PMPROT_AHSRUN(0),   //!< Disallow HSRUN mode
   SmcHighSpeedRun_Enable   = SMC_PMPROT_AHSRUN(1),   //!< Allow HSRUN mode
#else
   SmcHighSpeedRun_Disable  = 0, // Not supported
#endif
};

/**
 * Whether to exit VLP to Run mode on interrupt
 */
enum SmcExitVeryLowPowerOnInt {
#ifdef SMC_PMCTRL_LPWUI
   SmcExitVeryLowPowerOnInt_Disable = SMC_PMCTRL_LPWUI(0),  //!< Remain in VLP mode on interrupt
   SmcExitVeryLowPowerOnInt_Enable  = SMC_PMCTRL_LPWUI(1),  //!< Exit to RUN mode on interrupt
#else
   SmcExitVeryLowPowerOnInt_Disable = 0, // Not supported
#endif
};

/**
 * Sets Run mode
 */
enum SmcRunMode {
   SmcRunMode_Normal       = SMC_PMCTRL_RUNM(0),   //!< Normal run mode (RUN)
   SmcRunMode_VeryLowPower = SMC_PMCTRL_RUNM(2),   //!< Very low power run mode (VLPR)
#ifdef SMC_PMPROT_AHSRUN
   SmcRunMode_HighSpeed    = SMC_PMCTRL_RUNM(3),   //!< High Speed Run mode (HSRUN)
#endif
};

/**
 * Sets Stop mode
 */
enum SmcStopMode {
   SmcStopMode_NormalStop         = SMC_PMCTRL_STOPM(0), //!< Normal Stop (STOP)
   SmcStopMode_VeryLowPowerStop   = SMC_PMCTRL_STOPM(2), //!< Very-Low-Power Stop (VLPS)
   SmcStopMode_LowLeakageStop     = SMC_PMCTRL_STOPM(3), //!< Low-Leakage Stop (LLSx)
   SmcStopMode_VeryLowLeakageStop = SMC_PMCTRL_STOPM(4), //!< Very-Low-Leakage Stop (VLLSx)
};

/**
 *  Partial Stop Option\n
 *  This field controls whether a Partial Stop mode is entered when STOPM=STOP\n
 *  Not all modes may be supported
 */
enum SmcPartialStopMode {
#ifdef SMC_STOPCTRL_PSTOPO
   SmcPartialStopMode_Normal   = SMC_STOPCTRL_PSTOPO(0), //!< Normal stop mode
   SmcPartialStopMode_Partial1 = SMC_STOPCTRL_PSTOPO(1), //!< Partial Stop with both system and bus clocks disabled
   SmcPartialStopMode_Partial2 = SMC_STOPCTRL_PSTOPO(2), //!< Partial Stop with system clock disabled and bus clock enabled
#endif
   SmcPartialStopMode_Normal   = 0, //!< No options supported
};

/**
 *  POR Power Option\n
 *  This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 */
enum SmcPowerOnReset {
   SmcPowerOnReset_Disable = SMC_STOPCTRL_PORPO(0),   //!< Power on reset in STOP disabled
   SmcPowerOnReset_Enable  = SMC_STOPCTRL_PORPO(1),   //!< Power on reset in STOP enabled
};

/**
 *  VLS or VLLS Mode Control\n
 *  This field controls which LLS/VLLS sub-mode to enter if STOPM=LLS/VLLS\n
 *  Not all modes may be supported
 */
enum SmcLowLeakageStopMode {
   SmcLowLeakageStopMode_VLLS0 = SMC_STOPCTRL_VLLSM(0),
   SmcLowLeakageStopMode_VLLS1 = SMC_STOPCTRL_VLLSM(1),
   SmcLowLeakageStopMode_VLLS2 = SMC_STOPCTRL_VLLSM(2),
   SmcLowLeakageStopMode_VLLS3 = SMC_STOPCTRL_VLLSM(3),
   SmcLowLeakageStopMode_LLS2  = SMC_STOPCTRL_LLSM(2),
   SmcLowLeakageStopMode_LLS3  = SMC_STOPCTRL_LLSM(3),
};

/**
 *  Indicates the current stop mode
 */
enum SmcStatus {
   // Run modes
   SmcStatus_hsrun  = SMC_PMSTAT_PMSTAT(1<<7),
   SmcStatus_run    = SMC_PMSTAT_PMSTAT(1<<0),
   SmcStatus_vlpr   = SMC_PMSTAT_PMSTAT(1<<2),

   // Sleep = Wait modes
   SmcStatus_vlpw   = SMC_PMSTAT_PMSTAT(1<<3),

   // Stop = DeepSleep modes
   SmcStatus_stop   = SMC_PMSTAT_PMSTAT(1<<1),
   SmcStatus_vlps   = SMC_PMSTAT_PMSTAT(1<<4),
   SmcStatus_lls    = SMC_PMSTAT_PMSTAT(1<<5),
   SmcStatus_vlls   = SMC_PMSTAT_PMSTAT(1<<6),
};

/**
 *  POR Power Option\n
 *  This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 */
enum SmcPowerOption {
   SmcPowerOption_Disable = SMC_VLLSCTRL_PORPO(0),
   SmcPowerOption_Enable  = SMC_VLLSCTRL_PORPO(1),
};

/**
 * @brief Template class representing the System Mode Controller (SMC)
 *
 * Partially based on Freescale Application note AN4503
 */
template <class Info>
class SmcBase_T {

protected:
   static constexpr volatile SMC_Type *smc = Info::smc;

public:

#ifndef SMC_PMCTRL_LPWUI
#define SMC_PMCTRL_LPWUI 0 // Not all target support this
#endif

   /**
    * Configure with settings from Configure.usbdmProject.
    */
   static void defaultConfigure() {
      smc->PMPROT   = Info::pmprot;
      smc->STOPCTRL = Info::stopctrl;
   }

   /**
    * Enable the given power modes.\n
    * A mode must be enabled before it can be entered.
    *
    * @param[in] smcVeryLowPower        Allows VLPR, VLPW, and VLPS modes
    * @param[in] smcLowLeakageStop      Allows LLSx modes
    * @param[in] smcVeryLowLeakageStop  Allows VLLSx modes
    * @param[in] smcHighSpeedRun        Allows HSRUN mode (if supported)
    *
    * @note This is a write-once-after-reset operation
    */
   static ErrorCode enablePowerModes(
         SmcVeryLowPower         smcVeryLowPower,
         SmcLowLeakageStop       smcLowLeakageStop       = SmcLowLeakageStop_Disable,
         SmcVeryLowLeakageStop   smcVeryLowLeakageStop   = SmcVeryLowLeakageStop_Disable,
         SmcHighSpeedRun         smcHighSpeedRun         = SmcHighSpeedRun_Disable ) {

      uint8_t mask = smcVeryLowPower|smcLowLeakageStop|smcVeryLowLeakageStop|smcHighSpeedRun;
      smc->PMPROT = mask;
      return E_NO_ERROR;
   }

   /**
    * Allows the detailed operation in STOP mode to be controlled.
    *
    * @param[in] smcLowLeakageStopMode  Controls which LLS/VLLS sub-mode to enter if STOPM=LLS/VLLS
    * @param[in] smcPowerOnReset        Controls whether the POR detect circuit is enabled in VLLS0 mode
    * @param[in] smcPartialStopMode     Controls whether a Partial Stop mode is entered when STOPM=STOP (is supported)
    */
   static void setStopOptions(
         SmcLowLeakageStopMode   smcLowLeakageStopMode,
         SmcPowerOnReset         smcPowerOnReset,
         SmcPartialStopMode      smcPartialStopMode=SmcPartialStopMode_Normal) {

      smc->STOPCTRL = smcPartialStopMode|smcPowerOnReset|smcLowLeakageStopMode;
   }

   /**
    * Get current power status
    *
    * @return SmcStatus value indicating operating mode
    */
   static SmcStatus getPowerStatus() {

      return (SmcStatus)(smc->PMSTAT);
   }

   /**
    * Enter Run Mode
    *
    * @param[in]  smcRunMode  Mode to enter
    *
    * @return E_NO_ERROR                 No error
    * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to smcRunMode from current run mode
    */
   static ErrorCode enterRunMode(SmcRunMode smcRunMode) {
#ifdef SMC_PMPROT_AHSRUN
      SmcStatus smcStatus = getPowerStatus();
#endif
      switch(smcRunMode) {
         case SmcRunMode_Normal:
            smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
            while (getPowerStatus() != SmcStatus_run) {
               __asm__("nop");
            }
            break;
#ifdef SMC_PMPROT_AHSRUN
         case SmcRunMode_HighSpeed:
            if (smcStatus != SmcStatus_run) {
               // Can only transition from RUN mode
               return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
            }
            smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
            while (getPowerStatus() != SmcStatus_hsrun) {
               __asm__("nop");
            }
            break;
#endif
         case SmcRunMode_VeryLowPower:
#ifdef SMC_PMPROT_AHSRUN
            if (smcStatus != SmcStatus_run) {
               // Can only transition from RUN mode
               return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
            }
#endif
            smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
            while (getPowerStatus() != SmcStatus_vlpr) {
               __asm__("nop");
            }
            break;
         default:
            return setErrorCode(E_ILLEGAL_PARAM);
      }
      return E_NO_ERROR;
   }

   /**
    * Set Stop Mode to enter on Sleep-Now or Sleep-On-Exit
    *
    * @param[in]  smcStopMode             Stop mode to set
    */
   static void setStopMode(SmcStopMode smcStopMode) {

      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_STOPM_MASK)|smcStopMode;
      // Make sure write completes
      (void)smc->PMCTRL;
   }

   /**
    * Enter Stop Mode
    *
    * @param[in]  smcStopMode Stop mode to set
    */
   static void enterStopMode(SmcStopMode smcStopMode) {
      setStopMode(smcStopMode);
      deepSleep();
   }

#ifdef SMC_PMCTRL_LPWUI_MASK
   /**
    * Select VLP action on interrupt when in VLP modes (VLPR, VLPW or VLPS).
    *
    * @param[in]  smcExitVeryLowPowerOnInt Whether to exit from any VLP mode to RUN mode on interrupt
    */
   static void setExitVeryLowPowerOnInterrupt(SmcExitVeryLowPowerOnInt smcExitVeryLowPowerOnInt) {
      if (smcExitVeryLowPowerOnInt) {
         smc->PMCTRL |= SMC_PMCTRL_LPWUI_MASK;
      }
      else {
         smc->PMCTRL &= ~SMC_PMCTRL_LPWUI_MASK;
      }
      // Make sure write completes
      (void)smc->PMCTRL;
   }
#else
   /**
    * Set action on interrupt when in VLP modes (VLPR, VLPW or VLPS).
    *
    * @param[in]  SmcExitVeryLowPowerOnInt   Not supported
    *
    * @note Not supported
    */
   static void setVlpInterruptAction(SmcExitVeryLowPowerOnInt) {
   }

#endif

   /**
    * Enter Sleep mode (Kinetis WAIT mode)
    *
    * In this mode the core clock is disabled (no code executing),
    * but bus clocks are enabled (peripheral modules are operational).
    *
    * This function can be used to enter normal WAIT mode or VLPW mode
    * depending upon current run mode.
    *
    * Mode transitions:
    * - RUN  -> WAIT
    * - VLPR -> VLPW
    *
    * NOTE: Some modules include a programmable option to disable
    * them in wait mode. If those modules are programmed to disable
    * in wait mode, they will not be able to generate interrupts to
    * wake the core.
    *
    * WAIT mode is exited using any enabled interrupt or RESET.
    *
    * For Kinetis K:
    * If in VLPW mode, the statue of the SMC_PMCTRL[LPWUI] bit
    * determines if the processor exits to VLPR or RUN mode.
    * Use setExitVeryLowPowerOnInterrupt() to modify this action.
    *
    * For Kinetis L:
    * LPWUI does not exist.
    * Exits with an interrupt from VLPW will always be back to VLPR.
    * Exits from an interrupt from Wait will always be back to Run.
    */
   static void sleep() {
      SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
      __WFI();
   }

   /**
    * Enter Deep Sleep mode
    */
   static void deepSleep() {
      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
      __WFI();
   }
};

#ifdef USBDM_SMC_IS_DEFINED
/**
 * Class representing SMC
 */
using Smc = SmcBase_T<SmcInfo>;

#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* SMC_H_ */
